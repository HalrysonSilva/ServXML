unit MENU;

interface

uses
  // Windows e sistema
  Winapi.Windows, Winapi.Messages, Winapi.ShellAPI,

  // Sistema padrão Delphi
  System.SysUtils, System.Variants, System.Classes, System.IniFiles,
  System.DateUtils, System.Math, System.Zip, System.IOUtils,
  System.RegularExpressions, StrUtils,

  // VCL e componentes visuais
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls,
  Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids,
  Vcl.Buttons, Vcl.ExtDlgs, Vcl.Samples.Spin, Vcl.Imaging.jpeg, Vcl.FileCtrl,

  // Data e banco de dados
  Data.DB, Datasnap.DBClient,

  // Ole e navegador
  OleCtrls, SHDocVw,

  // Indy (envio de e-mail e rede)
  IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient,
  IdExplicitTLSClientServerBase, IdMessageClient, IdSMTPBase, IdSMTP,
  IdIOHandler, IdIOHandlerSocket, IdIOHandlerStack, IdSSL, IdSSLOpenSSL,
  IdMessage, IdAttachmentFile,

  // XML
  XMLIntf, XMLDoc, zlib,

  // ACBr - NF-e e utilitários
  ACBrBase, ACBrUtil, ACBrUtil.FilesIO,
  ACBrDFe, ACBrDFeSSL, ACBrDFeReport, ACBrDFeDANFeReport,
  ACBrNFe, ACBrNFeNotasFiscais, ACBrNFeWebServices, ACBrNFe.Classes,
  ACBrNFeDANFEClass, ACBrNFeDANFeESCPOS,
  ACBrMail, ACBrPosPrinter,ACBrConsts,ACBrDFeUtil,ACBrUtil.Strings;

type
  Tfrmmenu = class(TForm)
    Panel1: TPanel;
    Label1: TLabel;
    DBTextempresa: TDBText;
    DBTextcnpj: TDBText;
    DTinicio: TDateTimePicker;
    DTfim: TDateTimePicker;
    Label2: TLabel;
    Label3: TLabel;
    Label4: TLabel;
    cmbempresa: TComboBox;
    Panel2: TPanel;
    btnexportar: TButton;
    IdSMTP1: TIdSMTP;
    IdMessage1: TIdMessage;
    IdSSLIOHandlerSocketOpenSSL1: TIdSSLIOHandlerSocketOpenSSL;
    btnemail: TButton;
    CDSQUEBRA: TClientDataSet;
    DSCDSQUEBRA: TDataSource;
    btnconfig: TButton;
    btnmesanterior: TButton;
    btnmesatual: TButton;
    OpenDialog1: TOpenDialog;
    CMBMODELO: TComboBox;
    Label7: TLabel;
    Btnconsultar: TBitBtn;
    opcoes: TPageControl;
    Emitidas: TTabSheet;
    Label8: TLabel;
    LABELTOTAL: TLabel;
    labelvaloremitido: TLabel;
    dbgridvendas: TDBGrid;
    Inutilizar: TTabSheet;
    Panel3: TPanel;
    Label5: TLabel;
    labelfaltantes: TLabel;
    DBgridfaltante: TDBGrid;
    cmbserie: TComboBox;
    Label9: TLabel;
    Consulta: TTabSheet;
    Panel5: TPanel;
    editconsulta: TEdit;
    Label10: TLabel;
    btnbuscar: TButton;
    editmodelo: TEdit;
    Label12: TLabel;
    Label11: TLabel;
    editcodemitente: TEdit;
    Panel6: TPanel;
    btninutilizaespc: TButton;
    btninufaltante: TButton;
    btnxmllista: TButton;
    btnconsultinu: TButton;
    btnimportar: TButton;
    btnlimpalista: TButton;
    Corrigirnota: TTabSheet;
    Panel4: TPanel;
    Label6: TLabel;
    memoemail: TMemo;
    btnlimpalog: TButton;
    Panel7: TPanel;
    DBGridNOTASPERDIDAS: TDBGrid;
    Label13: TLabel;
    Panel8: TPanel;
    brnconsultavenda: TButton;
    Panel10: TPanel;
    Label14: TLabel;
    dbgridvendaspendente: TDBGrid;
    btnlimpavenda: TButton;
    Panel9: TPanel;
    Label22: TLabel;
    DBGridsequencia: TDBGrid;
    EDITPESQPEDIDO: TEdit;
    Label23: TLabel;
    btnconsultasefaz: TButton;
    Panel11: TPanel;
    BTNALTERARNUMNFCE: TButton;
    editalteraultnumusado: TEdit;
    Label15: TLabel;
    Editselecionaserie: TEdit;
    Label21: TLabel;
    Label20: TLabel;
    editregistro: TEdit;
    Label18: TLabel;
    btnconsultarserie: TButton;
    editserieusada: TEdit;
    Label17: TLabel;
    Label16: TLabel;
    Label19: TLabel;
    Label24: TLabel;
    Label25: TLabel;
    btnimprimir: TButton;
    Pendentes: TTabSheet;
    Panel12: TPanel;
    Label26: TLabel;
    Labelvalorpendente: TLabel;
    labelpendentes: TLabel;
    Panel14: TPanel;
    btnconsultastatus: TButton;
    btnreenviar: TButton;
    btnsalvaxmlconsu: TButton;
    btnalteraxml: TButton;
    btnveriinutiliza: TButton;
    btnhoje: TButton;
    consultasefaz: TTabSheet;
    Panel15: TPanel;
    Panel16: TPanel;
    MEMOCONSULTA: TMemo;
    Panel18: TPanel;
    DBGridconsultasefaz: TDBGrid;
    Label28: TLabel;
    Label29: TLabel;
    Panel17: TPanel;
    btnconsultalista: TBitBtn;
    btnimportalista: TBitBtn;
    btnbuscachave: TBitBtn;
    Editchave: TEdit;
    Label30: TLabel;
    BTNLMPLISTACONSULTA: TBitBtn;
    btngerachave: TBitBtn;
    Editmdlnota: TEdit;
    Label31: TLabel;
    Editserie: TEdit;
    Editnumnota: TEdit;
    Label32: TLabel;
    Label33: TLabel;
    btnbaixaxml: TBitBtn;
    btnbuscadata: TButton;
    labeltotalconsulta: TLabel;
    btnatualizabanco: TButton;
    btnsalvagerado: TButton;
    btnpederro: TButton;
    labelvalordiver: TLabel;
    Labeltotaldiver: TLabel;
    Panel13: TPanel;
    Label27: TLabel;
    logpendentes: TMemo;
    brnaltpendente: TButton;
    Panel20: TPanel;
    DBGridPENDENTES: TDBGrid;
    btnlistanaousada: TButton;
    Button1: TButton;  // Não estava na lista de componentes, mas mantenho para a próxima etapa
    procedure FormCreate(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure CriarTabelaSERVXML;
    procedure CriarPastaPadrao;
    procedure CarregarEmitentes;
    procedure Selecionaemitente;
    procedure CarregarXML;
    procedure CORRIGIRDADOS;
    procedure ProcessarIntervaloNotas(ACodEmitente, AModelo, ASerie: Integer; ADataEmissao: TDateTime; ANotaInicial, ANotaFinal: Integer);
    procedure btnimportarClick(Sender: TObject);
    procedure SalvarChaveCorreta(const ACodNota: Integer; const ANovaChave: string);
    procedure ExportarXMLsMesAnterior;
    procedure CalcularTotalvendapendente;
    procedure btnconfigClick(Sender: TObject);
    procedure CalcularTotalNotasExibidas;

    procedure cmbempresaChange(Sender: TObject);
     procedure contaregistrosemitidos;
    procedure SalvarXMLsInutilizadosEUtilizados;
    procedure contaregistrosfaltantes;
    procedure ConsultarValorEmitido;
    procedure btninufaltanteClick(Sender: TObject);
    procedure btnmesanteriorClick(Sender: TObject);
    procedure btnmesatualClick(Sender: TObject);
    procedure BTNALTERARNUMNFCEClick(Sender: TObject);
    procedure ApagarArquivosXMLTemp;
    procedure btnexportarClick(Sender: TObject);
    procedure EnviarXMLPorEmail;
    procedure btnemailClick(Sender: TObject);
    procedure BtnconsultarClick(Sender: TObject);
    procedure btninutilizaespcClick(Sender: TObject);
    procedure btnconsultinuClick(Sender: TObject);
    procedure btnxmllistaClick(Sender: TObject);
    procedure CMBMODELOChange(Sender: TObject);
    procedure ConsultarNotaPerdida;
    procedure LimparCDSQuebra;
    procedure btnlimpalistaClick(Sender: TObject);
    procedure btnlimpalogClick(Sender: TObject);
    procedure brnconsultavendaClick(Sender: TObject);
    procedure btnlimpavendaClick(Sender: TObject);
    procedure AtualizarNumeroMaisRecente;
    procedure btnconsultarserieClick(Sender: TObject);
    procedure PularProximaNumeracaoNFCe;
    procedure CarregarSeriesEmitidas(Modelo: Integer);
    procedure UPDATEBANCO;

    procedure btnconsultasefazClick(Sender: TObject);
    procedure btnimprimirClick(Sender: TObject);

    procedure ConsultarVendasPendentes;
    procedure contaregistrospendente;
    procedure btnconsultastatusClick(Sender: TObject);
    procedure ExecutarUpdateNotasFiscais;
    procedure ModificarESalvarXMLGeracao;
    procedure InutilizarNotasFaltantes;
    procedure AuditarNotaSEFAZ;
    procedure ContarTotalDivergencias;
    procedure CalcularValorDivergencias;

    procedure btnbuscarClick(Sender: TObject);
    procedure btnhojeClick(Sender: TObject);
    procedure AtualizarStatusEProtocoloParaReenvio(const ACodNota: Integer; const AXMLChave: string;
    const ACStat: Integer; const AXMotivo: string; const AXMLProtocolo: string);
    procedure btnreenviarClick(Sender: TObject);
    procedure btnalteraxmlClick(Sender: TObject);
    procedure AtualizarStatusEProtocolo(const ACodNota: Integer; const AXMLChave: string;
    const ACStat: Integer; const AXMotivo: string; const AXMLProtocolo: string);
    procedure btnveriinutilizaClick(Sender: TObject);
    procedure SelecionarEmitenteAutomatico;
    procedure ConsultarPorChaveDireta;
    procedure btnbuscachaveClick(Sender: TObject);
    procedure ImportarListaChaves;

    procedure BitBtn1Click(Sender: TObject);
    procedure CriarEstruturaCDSConsultaChave;
    procedure btnimportalistaClick(Sender: TObject);

    procedure btnconsultalistaClick(Sender: TObject);
    procedure consultaxmllista;
    procedure BTNLMPLISTACONSULTAClick(Sender: TObject);
    procedure mudanotaparanegativo(const ACodNota: Integer; const ANumNota: Integer);
    procedure btngerachaveClick(Sender: TObject);
    procedure btnbaixaxmlClick(Sender: TObject);
    procedure ConsultarNotasPorPeriodo;
    procedure btnbuscadataClick(Sender: TObject);
    procedure ContarTotalConsultas;
    procedure btnatualizabancoClick(Sender: TObject);
    procedure btnsalvaxmlconsuClick(Sender: TObject);
    procedure btnsalvageradoClick(Sender: TObject);
    procedure btnpederroClick(Sender: TObject);

    procedure CorrigirPendenciasBaseadoEmServxml;
    procedure brnaltpendenteClick(Sender: TObject);
    procedure ForcarMigracaoXMLTemp;
    procedure AtualizarChavesCorretas;


     procedure CriarEstruturaCDSCorretas;
    procedure btnlistanaousadaClick(Sender: TObject);
    procedure Button1Click(Sender: TObject);

  private
    { Private declarations }

    // Variável de instância (Field) para a Thread, agora no local correto.
    FMonitorThread: TThread;

    // Métodos/Procedures Privadas


    procedure SalvarLogServxml(const ACodNota, ANumNota, ASerie, AModelo, ACodEmitente: Integer;
                               const AXMLProcInutNFe: string; const ACStat: Integer);

  public
    { Public declarations }


    function ExtrairChaveCorreta(const AXMotivo: string): string;
    function ValidarCertificado: Boolean;
    function BuscarXMLGeracao(const ACodNota: Integer): string;
    function MesclarXMLComProtocolo(const AXMLOriginal: string; const AXMLProtocoloSOAP: string): string;

    // Métodos/Procedures de Eventos e Ações













  end;








var
  frmmenu: Tfrmmenu;

implementation

{$R *.dfm}

uses CONEXAOBD, Frm_ACBrNFe, Frm_ConfiguraSerial, Frm_SelecionarCertificado,
  Frm_Status, FRM_EMAIL_PROGRESSO, TELAESPERA;

















function Tfrmmenu.ValidarCertificado: Boolean;
var
  CNPJCertificado, CNPJTela: String;
begin
  Result := False; // Assume que o certificado está incorreto

  // 🔹 **Solicita a seleção do certificado**
  frmACBrNFe.sbtnGetCertClick(frmACBrNFe.sbtnGetCert);

  // 🔹 **Obtém o CNPJ do certificado digital**
  CNPJCertificado := frmACBrNFe.ACBrNFe1.SSL.CertCNPJ;

  // 🔹 **Obtém o CNPJ exibido no `DBTextCNPJ`**
  CNPJTela := StringReplace(DBTextCNPJ.Caption, '.', '', [rfReplaceAll]); // Remove pontos
  CNPJTela := StringReplace(CNPJTela, '/', '', [rfReplaceAll]); // Remove barras
  CNPJTela := StringReplace(CNPJTela, '-', '', [rfReplaceAll]); // Remove traços

  // 🔹 **Verifica se os CNPJs são iguais**
  if CNPJCertificado = CNPJTela then
    Result := True // Certificado válido
  else
  begin
    ShowMessage('❌ O CNPJ do certificado NÃO corresponde ao CNPJ da empresa! Selecione o certificado correto.');
    Result := ValidarCertificado; // Chama novamente a função até selecionar corretamente
  end;
end;

procedure Tfrmmenu.CriarTabelaSERVXML;
begin
  try
    DataModule1.QRYCRIATABSERVXML.ExecSQL;
  except
    on E: Exception do
      ShowMessage('Erro ao executar a query QRYCRIATABSERVXML: ' + E.Message);
  end;
end;

procedure Tfrmmenu.CORRIGIRDADOS;
begin
  try
    DataModule1.QRYCORRIGEDADOS.ExecSQL;
  except
    on E: Exception do
      ShowMessage('Erro ao executar a query QRYCORRIGEDADOS: ' + E.Message);
  end;
end;


procedure Tfrmmenu.UPDATEBANCO;
begin
  try
    DataModule1.QRYupdatebanco.ExecSQL;
  except
    on E: Exception do
      ShowMessage('Erro ao executar a query QRYCRIATABSERVXML: ' + E.Message);
  end;
end;




procedure Tfrmmenu.CriarPastapadrao;
const
  PastaBase = 'C:\XMLSERVSIC';
  PastaInutilizada = 'C:\XMLSERVSIC\INUTILIZADA';
  PastaXML = 'C:\XMLSERVSIC\XML';
  PastaXMLTemp = 'C:\XMLSERVSIC\XMLTEMP';
  PastaLog = 'C:\XMLSERVSIC\LOG';
begin
  // Cria as pastas caso não existam
  ForceDirectories(PastaBase);
  ForceDirectories(PastaInutilizada);
  ForceDirectories(PastaXML);
  ForceDirectories(PastaXMLTemp);
  ForceDirectories(PastaLOG);

end;




procedure Tfrmmenu.Selecionaemitente;
var
  CodigoEmitente, RegimeTributario: Integer;
  TituloCertificado: String;
begin
  if cmbempresa.ItemIndex <> -1 then
  begin
    // Obtém o código do emitente armazenado no ComboBox
    CodigoEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

    // Atualiza a Query para buscar os dados do emitente
    DataModule1.QRYEMITENTE.Close;
    DataModule1.QRYEMITENTE.SQL.Text := 'SELECT * FROM NFE_EMITENTE WHERE Codigo = :Codigo';
    DataModule1.QRYEMITENTE.ParamByName('Codigo').AsInteger := CodigoEmitente;
    DataModule1.QRYEMITENTE.Open;

    if not DataModule1.QRYEMITENTE.IsEmpty then
    begin
      // Preenchendo os `TEdit` no formulário `frmACBrNFe`
      frmACBrNFe.edtEmitCNPJ.Text := DataModule1.QRYEMITENTE.FieldByName('CNPJ').AsString;
      frmACBrNFe.edtEmitIE.Text := DataModule1.QRYEMITENTE.FieldByName('Insc_Estadual').AsString;
      frmACBrNFe.edtEmitRazao.Text := DataModule1.QRYEMITENTE.FieldByName('Razao_Social').AsString;
      frmACBrNFe.edtEmitFantasia.Text := DataModule1.QRYEMITENTE.FieldByName('Nome_Fantasia').AsString;
      frmACBrNFe.edtEmitFone.Text := DataModule1.QRYEMITENTE.FieldByName('Fone').AsString;
      frmACBrNFe.edtEmitCEP.Text := DataModule1.QRYEMITENTE.FieldByName('CEP').AsString;
      frmACBrNFe.edtEmitLogradouro.Text := DataModule1.QRYEMITENTE.FieldByName('Endereco').AsString;
      frmACBrNFe.edtEmitNumero.Text := DataModule1.QRYEMITENTE.FieldByName('Numero').AsString;
      frmACBrNFe.edtEmitComp.Text := DataModule1.QRYEMITENTE.FieldByName('Complemento').AsString;
      frmACBrNFe.edtEmitBairro.Text := DataModule1.QRYEMITENTE.FieldByName('Bairro').AsString;
      frmACBrNFe.edtEmitCodCidade.Text := DataModule1.QRYEMITENTE.FieldByName('Cod_Mun').AsString;
      frmACBrNFe.edtEmitCidade.Text := DataModule1.QRYEMITENTE.FieldByName('Municipio').AsString;
      frmACBrNFe.edtEmitUF.Text := DataModule1.QRYEMITENTE.FieldByName('UF').AsString;

      // Exibindo Nome e CNPJ nos `DBText`
      DBTextempresa.Caption := DataModule1.QRYEMITENTE.FieldByName('Razao_Social').AsString;
      DBTextcnpj.Caption := DataModule1.QRYEMITENTE.FieldByName('CNPJ').AsString;

      // Selecionando automaticamente o regime tributário no `cbTipoEmpresa`
      case DataModule1.QRYEMITENTE.FieldByName('Reg_Contabil_Cod').AsInteger of
        1: frmACBrNFe.cbTipoEmpresa.ItemIndex := 0;
        2: frmACBrNFe.cbTipoEmpresa.ItemIndex := 1;
        3: frmACBrNFe.cbTipoEmpresa.ItemIndex := 2;
      else
        frmACBrNFe.cbTipoEmpresa.ItemIndex := -1;
      end;


    end
    else
    begin
      // Se não encontrar dados, limpa os campos
      frmACBrNFe.edtEmitCNPJ.Text := '';
      frmACBrNFe.edtEmitIE.Text := '';
      frmACBrNFe.edtEmitRazao.Text := '';
      frmACBrNFe.edtEmitFantasia.Text := '';
      frmACBrNFe.edtEmitFone.Text := '';
      frmACBrNFe.edtEmitCEP.Text := '';
      frmACBrNFe.edtEmitLogradouro.Text := '';
      frmACBrNFe.edtEmitNumero.Text := '';
      frmACBrNFe.edtEmitComp.Text := '';
      frmACBrNFe.edtEmitBairro.Text := '';
      frmACBrNFe.edtEmitCodCidade.Text := '';
      frmACBrNFe.edtEmitCidade.Text := '';
      frmACBrNFe.edtEmitUF.Text := '';

      DBTextempresa.Caption := '';
      DBTextcnpj.Caption := '';
      frmACBrNFe.cbTipoEmpresa.ItemIndex := -1;
      // frmACBrNFe.edtNumSerie.Text := ''; // Limpa caso não tenha um certificado vinculado
    end;
  end
  else
  begin
    // Se nenhum item estiver selecionado, limpa tudo
    frmACBrNFe.edtEmitCNPJ.Text := '';
    frmACBrNFe.edtEmitIE.Text := '';
    frmACBrNFe.edtEmitRazao.Text := '';
    frmACBrNFe.edtEmitFantasia.Text := '';
    frmACBrNFe.edtEmitFone.Text := '';
    frmACBrNFe.edtEmitCEP.Text := '';
    frmACBrNFe.edtEmitLogradouro.Text := '';
    frmACBrNFe.edtEmitNumero.Text := '';
    frmACBrNFe.edtEmitComp.Text := '';
    frmACBrNFe.edtEmitBairro.Text := '';
    frmACBrNFe.edtEmitCodCidade.Text := '';
    frmACBrNFe.edtEmitCidade.Text := '';
    frmACBrNFe.edtEmitUF.Text := '';

    DBTextempresa.Caption := '';
    DBTextcnpj.Caption := '';
    frmACBrNFe.cbTipoEmpresa.ItemIndex := -1;
    //frmACBrNFe.edtNumSerie.Text := ''; // Limpa caso nenhum emitente seja selecionado
  end;
end;




procedure Tfrmmenu.SelecionarEmitenteAutomatico;
var
  IniFile: String;
  Ini: TIniFile;
  CNPJSalvo: String;
  CNPJItem: String;
  i: Integer;
begin
  // --- 1. LER O CNPJ SALVO NO INI ---
  IniFile := ChangeFileExt(ParamStr(0), '.ini');
  Ini := TIniFile.Create(IniFile);
  try
    // Lê o CNPJ salvo na seção [Emitente]
    CNPJSalvo := Trim(Ini.ReadString('Emitente', 'CNPJ', ''));
  finally
    Ini.Free;
  end;

  // --- 2. LOCALIZAR E SELECIONAR NO COMBOBOX ---
  if CNPJSalvo = '' then
    Exit; // Sai se não houver CNPJ salvo

  // Itera sobre todos os itens carregados no cmbempresa
  for i := 0 to cmbempresa.Items.Count - 1 do
  begin
    // O formato do item é "Código - CNPJ" [cite: 329]
    CNPJItem := cmbempresa.Items[i];

    // Extrai o CNPJ do final da string. Exemplo: '123 - 45128852000105'
    if Pos('-', CNPJItem) > 0 then
    begin
      // Pega a parte após o hífen e remove espaços
      CNPJItem := Trim(Copy(CNPJItem, Pos('-', CNPJItem) + 1, Length(CNPJItem)));

      if CNPJItem = CNPJSalvo then
      begin
        // Encontrou o emitente correspondente ao CNPJ salvo
        cmbempresa.ItemIndex := i;

        // 3. APLICAR A SELEÇÃO
        Selecionaemitente; // Chama a rotina que preenche o frmACBrNFe, DBTextempresa, etc. [cite: 108]
        Exit;
      end;
    end;
  end;

  // Se o CNPJ for encontrado, mas não houver ItemIndex selecionado, limpamos os campos
  if cmbempresa.ItemIndex = -1 then
    Selecionaemitente;
end;







procedure Tfrmmenu.FormCreate(Sender: TObject);
begin


  // Verifique se o DataModule1 foi criado automaticamente
  if not Assigned(DataModule1) then
  begin
    ShowMessage('Erro: O DataModule1 não foi criado. Verifique as opções do projeto.');
    Exit;
  end;
  opcoes.ActivePage := Emitidas;
  // --- PASSO 1: ATIVAR A CONEXÃO COM O BANCO DE DADOS ---
  // A melhor prática é fazer isso apenas uma vez, antes de tudo.
  try
    if not DataModule1.ConDados.Connected then
    begin
      MemoEmail.Lines.Add('Iniciando conexão com o banco de dados...');
      Application.ProcessMessages;
      DataModule1.ConDados.Connected := True;
      MemoEmail.Lines.Add('? Conexão estabelecida com sucesso.');
    end;
  except
    on E: Exception do
    begin
      ShowMessage('? Falha ao conectar ao banco de dados: ' + E.Message);
      MemoEmail.Lines.Add('? Falha ao conectar ao banco de dados: ' + E.Message);
      Exit; // Sai do FormCreate se a conexão falhar
    end;
  end;

  // --- PASSO 2: EXECUTAR AS QUERIES DE INICIALIZAÇÃO ---
  try


    CriarPastaPadrao;
    dtinicio.Date := Now;
    dtfim.Date := Now;






    if Assigned(frmACBrNFe) then // Verifica se o formulário de configuração já está instanciado
  begin
      frmACBrNFe.LerConfiguracao;
      frmACBrNFe.ConfigurarComponente;
  end;



  except
    // Este bloco só será ativado se uma das procedures chamadas aqui falhar
    on E: Exception do
      ShowMessage('? Erro durante a inicialização do programa: ' + E.Message);
  end;
end;




procedure Tfrmmenu.FormShow(Sender: TObject);
begin
  // Define os diretórios nos edits ao iniciar o projeto

  frmACBrNFe.edtPathNFe.Text := 'C:\XMLSERVSIC\XMLTEMP';
  frmACBrNFe.edtPathInu.Text := 'C:\XMLSERVSIC\INUTILIZADA';
  frmACBrNFe.edtPathPDF.Text := 'C:\XMLSERVSIC\XML';

  CarregarEmitentes;
  SelecionarEmitenteAutomatico;



end;

procedure Tfrmmenu.brnaltpendenteClick(Sender: TObject);
var
  EsperaForm: TfrmEspera;
  PedidoAtual: Integer;
  TotalRegistros: Integer;
  Contador: Integer;
begin
  // 1. Validação inicial, usando a nova query QRYCARREGAVENDAS
  if not DataModule1.QRYCARREGAVENDAS.Active or DataModule1.QRYCARREGAVENDAS.IsEmpty then
  begin
    ShowMessage('⚠️ A lista de vendas pendentes (QRYCARREGAVENDAS) está vazia. Execute a consulta primeiro!');
    Exit;
  end;

  // 2. Preparar e exibir o Form de Espera
  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    TotalRegistros := DataModule1.QRYCARREGAVENDAS.RecordCount;
    EsperaForm.Label1.Caption := Format('Preparando para atualizar %d pedidos na NFE_XML...', [TotalRegistros]);
    EsperaForm.Show;
    Application.ProcessMessages;

    // 3. Iniciar o processo de atualização
    Contador := 0;
    DataModule1.QRYCARREGAVENDAS.DisableControls;
    DataModule1.QRYCARREGAVENDAS.First;

    // A Query auxiliar QRYupdatebanco será usada para o UPDATE.
    with DataModule1.QRYupdatebanco do
    begin
      try
        DataModule1.ConDados.StartTransaction; // Inicia a transação no SQL Server

        // Configura o comando UPDATE fora do loop para melhor performance.
        Close;
        SQL.Clear;
        SQL.Add('UPDATE NFE_XML SET Status = :pStatus WHERE Pedido = :pPedido'); //

        while not DataModule1.QRYCARREGAVENDAS.Eof do
        begin
          Inc(Contador);
          // Captura o Pedido da QRYCARREGAVENDAS
          PedidoAtual := DataModule1.QRYCARREGAVENDAS.FieldByName('PEDIDO').AsInteger;

          // Atualizar o Form de Espera
          EsperaForm.Label1.Caption := Format('Atualizando pedido %d... (%d de %d)', [PedidoAtual, Contador, TotalRegistros]);
          Application.ProcessMessages;

          // Executa o UPDATE na NFE_XML
          ParamByName('pStatus').AsString := 'G'; // Define o status como 'G'
          ParamByName('pPedido').AsInteger := PedidoAtual;
          ExecSQL;

          DataModule1.QRYCARREGAVENDAS.Next;
        end;

        DataModule1.ConDados.Commit; // Confirma todas as alterações.
        MemoEmail.Lines.Add(Format('✅ Sucesso: %d registros na NFE_XML atualizados para Status=''G''.', [Contador]));
        ShowMessage(Format('✅ Processo concluído! %d registros atualizados.', [Contador]));

      except
        on E: Exception do
        begin
          DataModule1.ConDados.Rollback; // Em caso de erro, desfaz a transação.
          MemoEmail.Lines.Add(Format('❌ Erro CRÍTICO ao atualizar NFE_XML (Rollback): %s', [E.Message]));
          ShowMessage('❌ Erro durante a atualização. Nenhuma alteração foi salva no banco.');
        end;
      end;
    end;

  finally
    DataModule1.QRYCARREGAVENDAS.EnableControls;
    if Assigned(EsperaForm) then
      FreeAndNil(EsperaForm);
      BtnconsultarClick (Sender);
      opcoes.ActivePage := Pendentes;


  end;
end;



procedure Tfrmmenu.brnconsultavendaClick(Sender: TObject);
var
  EsperaForm: TfrmEspera;
  DataInicio, DataFim: TDateTime;
  PedidoPesquisa: string;
  PedidoInt: Integer;
begin
  // PASSO 1: Exibir o Form de Espera
  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Show;
    Application.ProcessMessages;
  except
    EsperaForm := nil; // Se falhar, ignora sem travar
  end;

  // PASSO 2: Executar a consulta - TRAZENDO TODAS AS VENDAS ATIVAS
  try
    DataInicio := DTinicio.Date;
    DataFim := DTfim.Date;
    PedidoPesquisa := Trim(EDITPESQPEDIDO.Text);

    MemoEmail.Lines.Clear;
    MemoEmail.Lines.Add('🔍 Buscando todas as vendas ativas na TABEST3A (com ou sem Nota/Série)...');
    Application.ProcessMessages;

    with DataModule1.QRYCARREGAVENDAS do
    begin
      Close;
      SQL.Clear;

      // Query base: todas as vendas ativas (t.Venda = 1) no período/filtro
      SQL.Text :=
        'SELECT CONTROLE, IDEMPRESA, DATA, NOTA, SERIE, PEDIDO, VLPAGO ' +
        'FROM TABEST3A ' +
        'WHERE Venda = 1'; // Apenas vendas válidas (Não-Orçamentos)

      // Filtro por pedido
      if PedidoPesquisa <> '' then
      begin
        if not TryStrToInt(PedidoPesquisa, PedidoInt) then
          raise Exception.Create('Número de pedido inválido. Digite apenas números.');

        SQL.Add('AND Pedido = :Pedido');
        ParamByName('Pedido').AsInteger := PedidoInt;
      end
      else
      begin
        // Filtro por data
        SQL.Add('AND Data >= :DataInicio AND Data < DATEADD(DAY, 1, :DataFim)');
        ParamByName('DataInicio').AsDateTime := DataInicio;
        ParamByName('DataFim').AsDateTime := DataFim;
      end;

      SQL.Add('ORDER BY Pedido DESC');
      Open;
    end;

    // PASSO 3: Atualizar interface
    dbgridvendaspendente.DataSource := DataModule1.DSQRYCARREGAVENDAS;

  except
    on E: Exception do
    begin
      ShowMessage('❌ Erro ao consultar vendas: ' + E.Message);
      MemoEmail.Lines.Add('❌ Erro ao consultar vendas: ' + E.Message);
    end;
  end;

  // PASSO 4: Fechar o Form de Espera
  if Assigned(EsperaForm) then
  begin
    ContarTotalDivergencias;
    CalcularValorDivergencias;
    EsperaForm.Close;
    EsperaForm.Free;
  end;
end;




procedure Tfrmmenu.ContarTotalDivergencias;
begin
  // Atualiza o Labeltotaldiver com a contagem de registros da QRYVENDASPENDENTES
  if Assigned(DataModule1.QRYCARREGAVENDAS) and DataModule1.QRYCARREGAVENDAS.Active then
    Labeltotaldiver.Caption := 'Total de Registros: ' + IntToStr(DataModule1.QRYCARREGAVENDAS.RecordCount)
  else
    Labeltotaldiver.Caption := 'Total de Registros: 0';
end;

procedure Tfrmmenu.CalcularValorDivergencias;
var
  TotalValor: Currency; // Usamos Currency para valores monetários
begin
  TotalValor := 0;

  if Assigned(DataModule1.QRYCARREGAVENDAS) and DataModule1.QRYCARREGAVENDAS.Active then
  begin
    DataModule1.QRYCARREGAVENDAS.First;

    // Itera por todos os registros e soma a coluna VLPAGO
    while not DataModule1.QRYCARREGAVENDAS.Eof do
    begin
      // Verifica se o campo 'VLPAGO' não é nulo antes de somar
      if not DataModule1.QRYCARREGAVENDAS.FieldByName('VLPAGO').IsNull then
        TotalValor := TotalValor + DataModule1.QRYCARREGAVENDAS.FieldByName('VLPAGO').AsCurrency;

      DataModule1.QRYCARREGAVENDAS.Next;
    end;
  end;

  // Exibe o total formatado como moeda
  Labelvalordiver.Caption := FormatCurr('R$ #,##0.00', TotalValor);
  Application.ProcessMessages;
end;





procedure Tfrmmenu.btnconfigClick(Sender: TObject);
begin
  FrmACBrNFe.ShowModal;
end;

procedure Tfrmmenu.btnconsultalistaClick(Sender: TObject);
begin
consultaxmllista;
end;

procedure Tfrmmenu.BtnconsultarClick(Sender: TObject);

begin

    CarregarXML;

    ConsultarVendasPendentes;
end;




procedure Tfrmmenu.btnimportalistaClick(Sender: TObject);
begin
ImportarListaChaves;
end;

procedure Tfrmmenu.btnimportarClick(Sender: TObject);
var
  ArquivoTXT: TStringList;
  LinhaOriginal: string;
  LinhaProcessada: string;
  Notas: TArray<string>;
  NotaInicial, NotaFinal: Integer;
  CodEmitente: Integer;
  ModeloDigitado: string;
  SerieDigitada: string;
  ModeloAtual, SerieAtual, NotaAtual: Integer;
  DataEmissaoDaNota: TDateTime;
  StatusDaNota: String;
begin
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('? Por favor, **selecione uma empresa (emitente)** na lista antes de importar o arquivo de quebra de sequência.');
    Exit;
  end;

  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

  ModeloDigitado := InputBox('Informar Dados', 'Digite o Modelo da(s) Nota(s) (55 para NFe, 65 para NFCe):', '55');
  if ModeloDigitado = '' then
  begin
    ShowMessage('? Modelo da nota não informado. Operação cancelada.');
    Exit;
  end;

  SerieDigitada := InputBox('Informar Dados', 'Digite a Série da(s) Nota(s):', '1');
  if SerieDigitada = '' then
  begin
    ShowMessage('? Série da(s) nota(s) não informada. Operação cancelada.');
    Exit;
  end;

  try
    ModeloAtual := StrToInt(ModeloDigitado);
    SerieAtual := StrToInt(SerieDigitada);
  except
    on E: Exception do
    begin
      ShowMessage('? Erro: O Modelo e/ou a Série devem ser números válidos. ' + E.Message);
      Exit;
    end;
  end;

  OpenDialog1.Filter := 'Arquivos de Texto (*.txt)|*.txt|Todos os Arquivos (*.*)|*.*';
  OpenDialog1.Title := 'Selecione o arquivo TXT com os intervalos de notas (Formato: NotaInicial-NotaFinal)';

  if OpenDialog1.Execute then
  begin
    ArquivoTXT := TStringList.Create;
    try
      ArquivoTXT.LoadFromFile(OpenDialog1.FileName);

      // <<<< TRECHO CORRIGIDO >>>>
      // Garante que o ClientDataSet sempre tenha a estrutura correta.
      if CDSQUEBRA.Active then
        CDSQUEBRA.Close;

      CDSQUEBRA.FieldDefs.Clear;
      CDSQUEBRA.FieldDefs.Add('CodNota', ftInteger);
      CDSQUEBRA.FieldDefs.Add('CodEmitente', ftInteger);
      CDSQUEBRA.FieldDefs.Add('Num_Mod_Doc', ftInteger);
      CDSQUEBRA.FieldDefs.Add('Serie', ftInteger);
      CDSQUEBRA.FieldDefs.Add('NumNota', ftInteger);
      CDSQUEBRA.FieldDefs.Add('Data_Emissao', ftDateTime);
      CDSQUEBRA.FieldDefs.Add('StatusNota', ftString, 20);
      CDSQUEBRA.CreateDataSet;
      CDSQUEBRA.Open;
      // <<<< FIM DO TRECHO CORRIGIDO >>>>

      for LinhaOriginal in ArquivoTXT do
      begin
        LinhaProcessada := Trim(LinhaOriginal);
        if LinhaProcessada = '' then Continue;
        Notas := SplitString(LinhaProcessada, '-');

        if Length(Notas) = 2 then
        begin
          try
            NotaInicial := StrToInt(Trim(Notas[0]));
            NotaFinal := StrToInt(Trim(Notas[1]));

            if NotaInicial > NotaFinal then
            begin
              ShowMessage(Format('?? Aviso: Intervalo inválido "%s" (Nota Inicial > Nota Final). Esta linha será ignorada.', [LinhaProcessada]));
              Continue;
            end;

            for NotaAtual := NotaInicial to NotaFinal do
            begin
              StatusDaNota := 'Não Encontrada';
              DataEmissaoDaNota := Date;

              // --- VERIFICAÇÃO NA SERVXML (INUTILIZADA) ---
              with DataModule1.QRYBUSCARNOTAS do
              begin
                Close;
                SQL.Text := 'SELECT CodEmitente, Num_Mod_Doc, Serie, Data_emissao FROM SERVXML ' +
                            'WHERE NumNota = :NumNota ' +
                            'AND CodEmitente = :CodEmitente ' +
                            'AND Num_Mod_Doc = :Num_Mod_Doc ' +
                            'AND Serie = :Serie';
                ParamByName('NumNota').AsInteger := NotaAtual;
                ParamByName('CodEmitente').AsInteger := CodEmitente;
                ParamByName('Num_Mod_Doc').AsInteger := ModeloAtual;
                ParamByName('Serie').AsInteger := SerieAtual;
                Open;

                if not IsEmpty then
                begin
                  CodEmitente := FieldByName('CodEmitente').AsInteger;
                  ModeloAtual := FieldByName('Num_Mod_Doc').AsInteger;
                  SerieAtual := FieldByName('Serie').AsInteger;
                  DataEmissaoDaNota := FieldByName('Data_emissao').AsDateTime;
                  StatusDaNota := 'Inutilizada (BD)';
                end;
                Close;
              end;

              // --- VERIFICAÇÃO NA NFE_XML (SE NÃO ENCONTRADA) ---
              if StatusDaNota = 'Não Encontrada' then
              begin
                with DataModule1.QRYBUSCARNOTAS do
                begin
                  Close;
                  SQL.Text := 'SELECT CodEmitente, Num_Mod_Doc, Serie, Data_Emissao, Status FROM NFE_XML ' +
                              'WHERE NumNota = :NumNota ' +
                              'AND CodEmitente = :CodEmitente ' +
                              'AND Num_Mod_Doc = :Num_Mod_Doc ' +
                              'AND Serie = :Serie';
                  ParamByName('NumNota').AsInteger := NotaAtual;
                  ParamByName('CodEmitente').AsInteger := CodEmitente;
                  ParamByName('Num_Mod_Doc').AsInteger := ModeloAtual;
                  ParamByName('Serie').AsInteger := SerieAtual;
                  Open;

                  if not IsEmpty then
                  begin
                    CodEmitente := FieldByName('CodEmitente').AsInteger;
                    ModeloAtual := FieldByName('Num_Mod_Doc').AsInteger;
                    SerieAtual := FieldByName('Serie').AsInteger;
                    DataEmissaoDaNota := FieldByName('Data_Emissao').AsDateTime;

                    if FieldByName('Status').AsString = 'I' then
                      StatusDaNota := 'Inutilizada (BD)'
                    else if FieldByName('Status').AsString = 'T' then
                      StatusDaNota := 'Transmitida'
                    else if FieldByName('Status').AsString = 'C' then
                      StatusDaNota := 'Cancelada'
                    else if FieldByName('Status').AsString = 'G' then // <-- NOVO FILTRO PARA STATUS 'G'
                      StatusDaNota := 'PENDENTE'                     // <-- CLASSIFICADO COMO PENDENTE
                    else
                      StatusDaNota := 'Desconhecido';                    // <-- Status Desconhecido também é PENDENTE
                  end;
                  Close;
                end;
              end;

              ProcessarIntervaloNotas(CodEmitente, ModeloAtual, SerieAtual, DataEmissaoDaNota, NotaAtual, NotaAtual);

              // Atualiza Status no ClientDataSet
              CDSQUEBRA.Edit;
              CDSQUEBRA.FieldByName('StatusNota').AsString := StatusDaNota;
              CDSQUEBRA.Post;
            end;

          except
            on E: Exception do
            begin
              ShowMessage(Format('? Erro ao processar o intervalo "%s": %s. Esta linha será ignorada.', [LinhaProcessada, E.Message]));
            end;
          end;
        end
        else
        begin
          ShowMessage(Format('?? Formato inválido na linha "%s". O formato esperado é "NotaInicial-NotaFinal". Esta linha será ignorada.', [LinhaProcessada]));
        end;
      end;

      ShowMessage('? Importação e preenchimento da lista de notas a inutilizar concluídos com sucesso!');
      contaregistrosfaltantes;
    finally
      ArquivoTXT.Free;
    end;
  end
  else
  begin
    ShowMessage('Importação de arquivo TXT cancelada pelo usuário.');
  end;
end;















procedure Tfrmmenu.btnimprimirClick(Sender: TObject);
var
  PeriodoStr, NomeEmpresaStr: string;
begin
  // ---------------------------------------------------------------------------
  // PASSO 1: VERIFICAR SE HÁ DADOS PARA IMPRIMIR
  // ---------------------------------------------------------------------------
  // Acessamos a query no DataModule para garantir que a consulta já foi executada.
  if not DataModule1.QRYBUSCAXML.Active or DataModule1.QRYBUSCAXML.IsEmpty then
  begin
    ShowMessage('Não há dados carregados para imprimir.' + #13#10 +
                'Por favor, execute a consulta primeiro.');
    Exit;
  end;

  // ---------------------------------------------------------------------------
  // PASSO 2: PREPARAR E EXECUTAR O RELATÓRIO
  // ---------------------------------------------------------------------------
  try
    // Ação 1: Ligar o componente de dados do relatório (frxDBDataset1)
    // à sua query que contém os resultados (QRYBUSCAXML). Ambos estão no DataModule.
    // O nome 'frxDBDataset1' foi confirmado pela sua imagem.
    DataModule1.frxdsNotas.DataSet := DataModule1.QRYBUSCAXML;

    // Ação 2: Coletar as informações dos filtros que estão na tela (TForm1).
    NomeEmpresaStr := DBTextempresa.Caption;
    PeriodoStr := 'Período: ' + FormatDateTime('dd/mm/yyyy', DTinicio.Date) +
                  ' a ' + FormatDateTime('dd/mm/yyyy', DTfim.Date);

    // Ação 3: Enviar essas informações como variáveis para o relatório.
    // O componente do relatório (frxReportNotas) está no DataModule.
    DataModule1.frxReportNotas.Variables['NomeEmpresa'] := QuotedStr(NomeEmpresaStr);
    DataModule1.frxReportNotas.Variables['PeriodoFiltro'] := QuotedStr(PeriodoStr);

    // Ação 4: Comandar a impressão.
    // O FastReport irá abrir a caixa de diálogo de impressão do Windows.
    DataModule1.frxReportNotas.showreport;

  except
    on E: Exception do
      ShowMessage('Ocorreu um erro ao preparar a impressão do relatório: ' + E.Message);
  end;
end;



procedure Tfrmmenu.AtualizarNumeroMaisRecente;
var
  NumSerie, CodEmitente: Integer;
begin
  editregistro.Text := '';

  try
    NumSerie := StrToIntDef(editserieusada.Text, 0);
    if cmbempresa.ItemIndex = -1 then
    begin
      ShowMessage('Por favor, selecione uma empresa (emitente)!');
      Exit;
    end;
    CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

    if (NumSerie = 0) or (CodEmitente = 0) then
    begin
      ShowMessage('Selecione um emitente e digite um número de série válido!');
      Exit;
    end;

    // --- PARTE 1: Buscar o número MAIS RECENTE e exibi-lo no editregistro ---
    with DataModule1.QRYBUSCAULTIMANFCE do
    begin
      Close;
      SQL.Text :=
        'SELECT MAX(num_nota_fiscal) AS UltimoNumNFCE ' +
        'FROM nfe_cab ' +
        'WHERE num_mod_doc = 65 ' +
        '  AND num_serie = :NumSerie ' +
        '  AND codemitente = :CodEmitente;';
      ParamByName('NumSerie').AsInteger := NumSerie;
      ParamByName('CodEmitente').AsInteger := CodEmitente;
      Open;

      if not IsEmpty and not FieldByName('UltimoNumNFCE').IsNull then
        editregistro.Text := FieldByName('UltimoNumNFCE').AsString
      else
      begin
        ShowMessage('Nenhum NFC-e encontrado para a série informada.');
        editregistro.Text := '0';
      end;
      Close;
    end;

    // --- PARTE 2: Listar todos os números de nota, emitente e série (consulta simplificada) ---
    with DataModule1.QRYSequencia do
    begin
      Close;
      SQL.Text :=
        'SELECT num_nota_fiscal, codemitente, num_serie ' +
        'FROM nfe_cab ' +
        'WHERE num_mod_doc = 65 ' +
        '  AND num_serie = :NumSerie ' +
        '  AND codemitente = :CodEmitente ' +
        'ORDER BY num_nota_fiscal DESC;';

      ParamByName('NumSerie').AsInteger := NumSerie;
      ParamByName('CodEmitente').AsInteger := CodEmitente;
      Open;

      DataModule1.DSSequencia.DataSet := DataModule1.QRYSequencia;
      DBGridsequencia.DataSource := DataModule1.DSSequencia;
    end;

  except
    on E: Exception do
      ShowMessage('Erro ao buscar os dados: ' + E.Message);
  end;
end;


procedure Tfrmmenu.btnconsultarserieClick(Sender: TObject);
begin
AtualizarNumeroMaisRecente;
end;

// TRECHO REVISADO da procedure TForm1.btnConsultarXMLBancoClick




procedure Tfrmmenu.btnconsultastatusClick(Sender: TObject);
var
  EsperaForm: TfrmEspera;
  ChaveDaNota: string;
  NumeroDaNota: string;
  CodNotaAtual: Integer;
  cStat: Integer;
  xMotivo: string;
  sXMLComProtocolo: string;
  sXMLOriginal: string;
  sXMLFinal: string;
  ChaveCorreta: string;
  TotalRegistros: Integer;  // Variável para o total de registros
  Contador: Integer;        // Contador do loop
begin
  // *************************************************************
  // 1. VALIDAÇÃO E INICIALIZAÇÃO
  // *************************************************************
  if frmACBrNFe.edtNumSerie.Text = '' then
  begin
    ShowMessage('? O Número de Série do Certificado não está preenchido na configuração (Configurações > Certificado). Operação cancelada.');
    Exit;
  end;

  // CONFIGURAÇÃO DO ACBRNFE COM O CERTIFICADO SELECIONADO
  frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := frmACBrNFe.edtNumSerie.Text;

  if not DataModule1.QRYPSQPENDENTE.Active or DataModule1.QRYPSQPENDENTE.IsEmpty then
  begin
    ShowMessage('? A lista de notas pendentes está vazia. Execute a consulta de vendas pendentes primeiro!');
    Exit;
  end;

  // Prepara a interface de feedback
  logpendentes.Lines.Clear;
  logpendentes.Lines.Add('Iniciando consulta das chaves salvas na base...');
  Application.ProcessMessages;

  // 2. Cria e Exibe Tela de Espera
  EsperaForm := TfrmEspera.Create(Self);
  try
    // CALCULA O TOTAL ANTES DE INICIAR O LOOP
    TotalRegistros := DataModule1.QRYPSQPENDENTE.RecordCount;
    Contador := 0;

    EsperaForm.Position := poScreenCenter;
    EsperaForm.Label1.Caption := Format('Preparando para consultar %d chaves...', [TotalRegistros]);
    EsperaForm.Show;
    Application.ProcessMessages;

    // 3. ITERAÇÃO E CONSULTA DE CADA NOTA
    DataModule1.QRYPSQPENDENTE.DisableControls;
    DataModule1.QRYPSQPENDENTE.First;

    while not DataModule1.QRYPSQPENDENTE.Eof do
    begin
      Inc(Contador);

      // ATUALIZA O PROGRESSO
      EsperaForm.Label1.Caption := Format('Consultando Nota: %s ( %d de %d )...',
        [DataModule1.QRYPSQPENDENTE.FieldByName('NumNota').AsString, Contador, TotalRegistros]);
      Application.ProcessMessages;

      // 3.1. Captura as chaves de controle (PK e Chave de Acesso)
      logpendentes.Lines.Add(''); // LINHA DE SEPARAÇÃO VISUAL

      ChaveDaNota := DataModule1.QRYPSQPENDENTE.FieldByName('XMLchave').AsString;
      NumeroDaNota := DataModule1.QRYPSQPENDENTE.FieldByName('NumNota').AsString;
      CodNotaAtual := DataModule1.QRYPSQPENDENTE.FieldByName('CodNota').AsInteger;

      if Length(ChaveDaNota) = 44 then
      begin
        logpendentes.Lines.Add(Format('?? Consultando nota %s pela Chave %s...', [NumeroDaNota, Copy(ChaveDaNota, 35, 10)]));
        Application.ProcessMessages;

        // 3.2. CONSULTA NA SEFAZ (VIA ACBR)
        frmACBrNFe.ACBrNFe1.WebServices.Consulta.NFeChave := ChaveDaNota;
        frmACBrNFe.ACBrNFe1.WebServices.Consulta.Executar;

        // 3.3. CAPTURA O RETORNO COMPLETO
        cStat := frmACBrNFe.ACBrNFe1.WebServices.Consulta.cStat;
        xMotivo := frmACBrNFe.ACBrNFe1.WebServices.Consulta.xMotivo;
        sXMLComProtocolo := frmACBrNFe.ACBrNFe1.WebServices.Consulta.RetornoWS;

        logpendentes.Lines.Add(Format('? Resposta SEFAZ | Status: %d | Motivo: %s', [cStat, xMotivo]));

        // 3.4. TRATAMENTO E ATUALIZAÇÃO DA TABELA NFE_XML

        // === TRATAMENTO PARA ERRO 613 (Chave Incorreta) ===
        if cStat = 613 then
        begin
          logpendentes.Lines.Add('?? ERRO 613 DETECTADO! Chave de Acesso inválida/Inconsistente.');

          // Lógica de extração e salvamento da chave correta deve vir aqui:
          // ChaveCorreta := ExtrairChaveCorreta(xMotivo);
          // if ChaveCorreta <> '' then SalvarChaveCorreta(CodNotaAtual, ChaveCorreta);

          AtualizarStatusEProtocolo(CodNotaAtual, ChaveDaNota, cStat, xMotivo, sXMLComProtocolo);
        end
        // === FIM DO TRATAMENTO 613 ===

        else if (cStat = 100) or (cStat = 150) then // Autorizada ou Denegada
        begin
          // A) BUSCA O XML ORIGINAL NO BANCO (XMLGeracao)
          sXMLOriginal := BuscarXMLGeracao(CodNotaAtual);

          // B) MESCLA O XML ORIGINAL COM O PROTOCOLO DE RETORNO (Cria o <nfeProc> válido)
          sXMLFinal := MesclarXMLComProtocolo(sXMLOriginal, sXMLComProtocolo);

          // C) Atualiza a tabela com Status='T' e o XML completo (<nfeProc>)
          AtualizarStatusEProtocolo(CodNotaAtual, ChaveDaNota, cStat, xMotivo, sXMLFinal);

          logpendentes.Lines.Add('?? Nota AUTORIZADA! Aplicando Atualização...');
          ExecutarUpdateNotasFiscais; // Atualiza TABEST3A
        end
        else
        begin
          // Se Rejeitada ou com erro, salva o envelope SOAP (ou erro)
          AtualizarStatusEProtocolo(CodNotaAtual, ChaveDaNota, cStat, xMotivo, sXMLComProtocolo);
        end;

      end
      else
      begin
        logpendentes.Lines.Add('');
        logpendentes.Lines.Add(Format('?? Chave XML inválida (%s) para a nota %s. Pulando...', [ChaveDaNota, NumeroDaNota]));
      end;

      DataModule1.QRYPSQPENDENTE.Next;
    end;

    logpendentes.Lines.Add('---');
    logpendentes.Lines.Add('? Consulta de lista pendente concluída. Verifique os logs de Autorização/Rejeição.');
  finally
    // 4. FINALIZAÇÃO E LIMPEZA
    DataModule1.QRYPSQPENDENTE.EnableControls;
    if Assigned(EsperaForm) then
    begin
      ConsultarVendasPendentes;
      CarregarXML;
      ApagarArquivosXMLTemp;
      EsperaForm.Close;
      EsperaForm.Free;
    end;
  end;
end;














procedure Tfrmmenu.ExecutarUpdateNotasFiscais;
begin
  // Esta procedure atualiza a TABEST3A com Nota e Série das NFe/NFCe que foram Autorizadas (100) ou Denegadas (150).
  try
    // 1. Inicia a transação de banco de dados para garantir que a operação seja atômica.
    DataModule1.ConDados.StartTransaction;

    with DataModule1.QRYVERITABEST3A do
    begin
      Close;
      SQL.Clear;

      // 2. Monta o comando SQL de UPDATE
      // Ele junta TABEST3A com NFe_XML (pela coluna Pedido) e só atualiza os registros
      // que tenham o cStat de autorização/denegação no XML de transmissão.
      SQL.Text := 'UPDATE TABEST3A ' +
                  'SET TABEST3A.Nota = NFe_XML.NumNota, ' +
                  '    TABEST3A.Serie = NFe_XML.Serie ' +
                  'FROM TABEST3A ' +
                  'JOIN NFe_XML ON TABEST3A.Pedido = NFe_XML.Pedido ' +
                  'WHERE (NFe_XML.XMLTransmissao LIKE ''%<cStat>100</cStat>%'' ' +
                  '    OR NFe_XML.XMLTransmissao LIKE ''%<cStat>150</cStat>%'')';

      // 3. Executa o UPDATE
      ExecSQL;
    end;

    // 4. Confirma a transação no banco de dados.
    DataModule1.ConDados.Commit;


    Logpendentes.Lines.Add('As notas pendentes com XML autorizado (100 ou 150) foram corrigidas no banco de dados.');

  except
    on E: Exception do
    begin
      // 5. Em caso de erro, desfaz a transação.
      DataModule1.ConDados.Rollback;
      ShowMessage('❌ Erro ao tentar atualizar as notas fiscais na TABEST3A: ' + E.Message);
      Logpendentes.Lines.Add('❌ Erro ao tentar atualizar as notas fiscais na TABEST3A: ' + E.Message);
    end;
  end;
end;




procedure Tfrmmenu.btnconsultinuClick(Sender: TObject);
const
  URL_NFCE_SVRS = 'https://dfe-portal.svrs.rs.gov.br/NFCE/Inutilizacao'; // URL do Portal NFC-e SVRS
begin

  ShellExecute(0, 'open', PChar(URL_NFCE_SVRS), nil, nil, SW_SHOWNORMAL);

  MemoEmail.Lines.Add('🌐 Abrindo Portal NFC-e SVRS: ' + URL_NFCE_SVRS);
  Application.ProcessMessages;
end;








procedure Tfrmmenu.btnemailClick(Sender: TObject);
begin


    EnviarXMLPorEmail;


end;



procedure Tfrmmenu.btnexportarClick(Sender: TObject);

  BEGIN
       ExportarXMLsMesAnterior
 end;




procedure Tfrmmenu.btngerachaveClick(Sender: TObject);
var
  ANumNota, ASerie, AModelo: string;
begin
  // 1. Coleta dos dados dos Edits (Formulário GERAXML)
  // [Edit2, Editserie e Editmdlnota são seus campos de entrada]
  ANumNota := Trim(Editnumnota.Text);       // Número da Nota
  ASerie := Trim(Editserie.Text);     // Série
  AModelo := Trim(Editmdlnota.Text);  // Modelo (55 ou 65)

  // 2. Validação Mínima e Seleção de Emitente
  if (ANumNota = '') or (ASerie = '') or (AModelo = '') or (cmbempresa.ItemIndex = -1) then
  begin
    ShowMessage('⚠️ Por favor, selecione o Emitente e preencha o Número da Nota, a Série e o Modelo.');
    Exit;
  end;

  // 3. Chamada à função corrigida no Frm_ACBrNFe
  try
    // Chama a função que monta a chave com base no Emitente e nos parâmetros.
    Editchave.Text := frmACBrNFe.GerarChaveAcesso(ANumNota, ASerie, AModelo);

    // 4. Exibição do Resultado
    if StartsText('ERRO:', Editchave.Text) then
      MemoConsulta.Lines.Add('❌ Falha na Geração: ' + Editchave.Text)
    else
    begin
      ShowMessage('✅ Chave de Acesso gerada: ' + Editchave.Text);
      MemoConsulta.Lines.Add('✅ Chave gerada e pronta para consulta.');
    end;

  except
    on E: Exception do
      ShowMessage('❌ Erro inesperado ao tentar gerar a chave: ' + E.Message);
  end;
end;


procedure Tfrmmenu.btnhojeClick(Sender: TObject);
begin

  DTinicio.Date := now;

  DTfim.Date := now;
end;

procedure Tfrmmenu.btninufaltanteClick(Sender: TObject);

begin


  InutilizarNotasFaltantes;

end;

procedure Tfrmmenu.btnMesAnteriorClick(Sender: TObject);
var

  PrimeiroDia, UltimoDia: TDateTime;
begin
  // Obtém o primeiro dia do mês anterior
  PrimeiroDia := StartOfTheMonth(IncMonth(Date, -1));

  // Obtém o último dia do mês anterior
  UltimoDia := EndOfTheMonth(IncMonth(Date, -1));

  // Define os valores nos DateTimePickers
  dtinicio.Date := PrimeiroDia;
  dtfim.Date := UltimoDia;

  end;



procedure Tfrmmenu.btnMesAtualClick(Sender: TObject);

var

  PrimeiroDia, UltimoDia: TDateTime;
begin
  // Obtém o primeiro dia do mês atual
  PrimeiroDia := StartOfTheMonth(Date);

  // Obtém o último dia do mês atual
  UltimoDia := EndOfTheMonth(Date);

  // Define os valores nos DateTimePickers
  dtinicio.Date := PrimeiroDia;
  dtfim.Date := UltimoDia;


end;


procedure Tfrmmenu.btnpederroClick(Sender: TObject);
var
  PedidoPesquisa: string;
  PedidoInt: Integer;
begin
  // 1. COLETAR E VALIDAR O PEDIDO
  PedidoPesquisa := Trim(EDITPESQPEDIDO.Text);

  if PedidoPesquisa = '' then
  begin
    ShowMessage('⚠️ Por favor, digite o número do pedido no campo de pesquisa.');
    EDITPESQPEDIDO.SetFocus;
    Exit;
  end;

  if not TryStrToInt(PedidoPesquisa, PedidoInt) then
  begin
    ShowMessage('⚠️ Número de pedido inválido. Por favor, digite apenas números.');
    EDITPESQPEDIDO.SetFocus;
    Exit;
  end;

  try
    // 2. EXECUTAR A CONSULTA DIRETAMENTE NO SQL SERVER
    with DataModule1.QRYCARREGAVENDAS do
    begin
      Close;

      // SQL para buscar o pedido específico na TABEST3A onde a nota está pendente (Nota=0 ou NULL)
      SQL.Text := 'SELECT CONTROLE, IDEMPRESA,PEDIDO , DATA, NOTA, SERIE ' +
                  'FROM TABEST3A ' +
                  'WHERE Pedido = :Pedido ';


      ParamByName('Pedido').AsInteger := PedidoInt;

      Open;
    end;

    // 3. ATUALIZAR A INTERFACE
    // Conecta a DataSource do DBGrid com a Query
    dbgridvendaspendente.DataSource := DataModule1.DSQRYCARREGAVENDAS;

    // Exibe mensagem de feedback se nada for encontrado (sem usar logs)
    if DataModule1.QRYCARREGAVENDAS.IsEmpty then
      ShowMessage(Format('✅ Pedido %d não encontrado ou já foi emitido/processado.', [PedidoInt]));

  except
    on E: Exception do
    begin
      // Mantém a mensagem de erro APENAS se a consulta falhar
      ShowMessage('❌ Erro ao executar a busca do pedido: ' + E.Message);
    end;
  end;


end;




procedure Tfrmmenu.btnbaixaxmlClick(Sender: TObject);
const
  URL_NFCE_SVRS = 'https://dfe-portal.svrs.rs.gov.br/NFCESSL/DownloadXMLDFe'; // URL do Portal NFC-e SVRS
begin

  ShellExecute(0, 'open', PChar(URL_NFCE_SVRS), nil, nil, SW_SHOWNORMAL);

  MemoConsulta.Lines.Add('🌐 Abrindo Portal NFC-e SVRS: ' + URL_NFCE_SVRS);
  Application.ProcessMessages;

end;

procedure Tfrmmenu.btnbuscachaveClick(Sender: TObject);
begin
ConsultarPorChaveDireta;
end;

procedure Tfrmmenu.btnbuscadataClick(Sender: TObject);
begin
ConsultarNotasPorPeriodo;

end;

procedure Tfrmmenu.btnreenviarClick(Sender: TObject);
begin
  logpendentes.Lines.Clear;
  logpendentes.Lines.Add('>>> INICIANDO O REENVIO DE NOTAS PENDENTES <<<');
  Application.ProcessMessages;



  // 2. VALIDAÇÃO PÓS-PREPARAÇÃO
  if DataModule1.QRYPSQPENDENTE.IsEmpty then
  begin
    logpendentes.Lines.Add('✅ Lista de XMLs prontos para envio está vazia. Não há notas a reenviar.');
    ShowMessage('Não há notas pendentes com XML válido para serem reenviadas.');
    Exit;
  end;

  // 3. CHAMA O FORMULÁRIO AUXILIAR PARA INICIAR O ENVIO EM LOTE
  try
    logpendentes.Lines.Add('📤 Iniciando Reenvio...');

    // CORREÇÃO: Chama a procedure APENAS UMA VEZ e passa a referência do botão de envio correto como Sender.
    // Usaremos o nome que você forneceu: REENVIANOTASSEFAZ
    // (Se o nome correto no Frm_ACBrNFe for btnCarregarXMLEnviarClick, ajuste a chamada).
    frmACBrNFe.REENVIANOTASSEFAZ;

  except
    on E: Exception do
    begin
      logpendentes.Lines.Add('❌ ERRO CRÍTICO na EXECUÇÃO do Envio: ' + E.Message);
      ShowMessage('❌ Erro no ciclo de envio ACBr: ' + E.Message);
    end;
  end;

  logpendentes.Lines.Add('>>> CICLO DE REENVIO CONCLUÍDO <<<');
  Application.ProcessMessages;

  // Opcional: Recarrega a lista de vendas pendentes para atualizar a tela principal
  ConsultarVendasPendentes;
  ApagarArquivosXMLTemp;

end;



procedure Tfrmmenu.btnsalvageradoClick(Sender: TObject);
var
  XMLContent: TStringList;
  NomeArquivo: String;
  XMLTextoSalvar: String;
  NumNota, Serie, Modelo: String;
  StatusNota: String;
  CaminhoCompleto: String;
  CaminhoArquivo: string;
  PastaDestino: String;
  Contador: Integer;
  RazaoSocial, CNPJ, NomeArquivoZip: String;
  ZipFile: TZipFile;
  LinhaTXT: TStringList;
begin

  Application.ProcessMessages;

  XMLContent := TStringList.Create;
  LinhaTXT := TStringList.Create;
  ZipFile := TZipFile.Create;
  Contador := 0;

  try
    // 1. VALIDAÇÃO E COLETAR DADOS
    if cmbempresa.ItemIndex = -1 then
    begin
      ShowMessage('Selecione uma empresa para continuar.');
      Exit;
    end;

    if (not DataModule1.QRYNOTAPERDIDA.Active) or (DataModule1.QRYNOTAPERDIDA.IsEmpty) then
    begin
      ShowMessage('Execute uma consulta na aba "Consulta" e verifique a grade.');
      Exit;
    end;

    // Coleta dados da tela
    RazaoSocial := DBTextempresa.Caption;
    CNPJ := StringReplace(DBTextcnpj.Caption, '.', '', [rfReplaceAll]);

    // Define a pasta de destino para XMLs de Geração
    PastaDestino := 'C:\XMLSERVSIC\XMLTEMP_GERACAO_' + FormatDateTime('yyyymmdd', Now) + '\';
    ForceDirectories(PastaDestino);

    Application.ProcessMessages;

    // Cabeçalho do relatório
    LinhaTXT.Add('RELATORIO DE XMLS DE GERAÇÃO (SEM PROTOCOLO)');
    LinhaTXT.Add(Format('Total de registros na grade: %d', [DataModule1.QRYNOTAPERDIDA.RecordCount]));
    LinhaTXT.Add('');

    DataModule1.QRYNOTAPERDIDA.DisableControls;
    DataModule1.QRYNOTAPERDIDA.First;

    // 2. ITERAÇÃO SOBRE TODOS OS REGISTROS
    while not DataModule1.QRYNOTAPERDIDA.Eof do
    begin
      Inc(Contador);
      XMLTextoSalvar := '';

      // 2.1. Coleta das chaves do registro atual
      with DataModule1.QRYNOTAPERDIDA do
      begin
        NumNota := FieldByName('num_nota_fiscal').AsString;
        Serie := FieldByName('Num_Serie').AsString;
        Modelo := FieldByName('Num_Mod_Doc').AsString;
        StatusNota := FieldByName('St_Retorno').AsString;
      end;

      // 2.2. BUSCA SOMENTE XMLGeracao na NFE_XML
      with DataModule1.QRYVERIFICANFE_XML do
      begin
        Close;
        // Seleciona APENAS XMLGeracao [cite: 255]
        SQL.Text := 'SELECT XMLGeracao FROM NFE_XML WHERE NumNota = :numnota AND Serie = :serie AND Num_Mod_Doc = :modelo';
        ParamByName('numnota').AsString := NumNota;
        ParamByName('serie').AsString := Serie;
        ParamByName('modelo').AsString := Modelo;
        Open;

        if not IsEmpty then
          XMLTextoSalvar := FieldByName('XMLGeracao').AsString;

        Close;
      end;

      // 2.3. Salvar o arquivo XML (se encontrado)
      if XMLTextoSalvar <> '' then
      begin
        // Cria o nome do arquivo com a tag "_GERACAO"
        NomeArquivo := Format('XML_Nota_%s_S%s_M%s_%s_GERACAO.xml', [NumNota, Serie, Modelo, StringReplace(StatusNota, ' ', '_', [rfReplaceAll])]);
        CaminhoCompleto := IncludeTrailingPathDelimiter(PastaDestino) + NomeArquivo;

        XMLContent.Text := XMLTextoSalvar;
        XMLContent.SaveToFile(CaminhoCompleto);

        LinhaTXT.Add(Format('Nota: %s | Status: %s | Arquivo: %s', [NumNota, StatusNota, NomeArquivo]));
      end
      else
      begin
        LinhaTXT.Add(Format('Nota: %s | Aviso: XML de Geração NÃO encontrado.', [NumNota]));
      end;

      DataModule1.QRYNOTAPERDIDA.Next;
    end;

    // Salva o relatório e compacta
    LinhaTXT.SaveToFile(PastaDestino + 'Relatorio_XMLs_Geracao.txt');

    NomeArquivoZip := Format('C:\XMLSERVSIC\%s_%s_XMLS_GERACAO.zip', [
      StringReplace(CNPJ, ' ', '', [rfReplaceAll]),
      FormatDateTime('YYYYMMDD_HHNN', Now)
    ]);

    ZipFile.Open(NomeArquivoZip, zmWrite);
    try
      for CaminhoArquivo in TDirectory.GetFiles(PastaDestino, '*', TSearchOption.soTopDirectoryOnly) do
        ZipFile.Add(CaminhoArquivo, ExtractFileName(CaminhoArquivo));
    finally
      ZipFile.Close;
    end;

    ShowMessage(Format('Processo concluído! %d XMLs de Geração salvos e compactados em: %s', [Contador, NomeArquivoZip]));

  finally
    DataModule1.QRYNOTAPERDIDA.EnableControls;
    XMLContent.Free;
    LinhaTXT.Free;
    FreeAndNil(ZipFile);
    if DirectoryExists(PastaDestino) then TDirectory.Delete(PastaDestino, True);
    Application.ProcessMessages;
  end;
end;



procedure Tfrmmenu.btnsalvaxmlconsuClick(Sender: TObject);

var

  XMLContent: TStringList;

  NomeArquivo: String;

  XMLTextoSalvar: String;

  NumNota, Serie, Modelo: String;

  StatusNota: String;

  CaminhoCompleto: String;

  CaminhoArquivo: string;

  PastaDestino: String;

  Contador: Integer;

  // Variáveis para Compactação e Nomes

  RazaoSocial, CNPJ, NomeArquivoZip: String;

  ZipFile: TZipFile;

  LinhaTXT: TStringList;

begin

  Application.ProcessMessages;

  XMLContent := TStringList.Create;
  LinhaTXT := TStringList.Create;
  ZipFile := TZipFile.Create;
  Contador := 0;

  try

    // 1. VALIDAÇÃO E COLETAR DADOS DO EMITENTE
    if cmbempresa.ItemIndex = -1 then
    begin
      ShowMessage('Selecione uma empresa para continuar.');
      Exit;
    end;

    if (not DataModule1.QRYNOTAPERDIDA.Active) or (DataModule1.QRYNOTAPERDIDA.IsEmpty) then
    begin
      ShowMessage('Execute uma consulta na aba "Consulta" e verifique a grade.');
      Exit;
    end;

    // Coleta os dados da tela principal
    RazaoSocial := DBTextempresa.Caption;
    CNPJ := StringReplace(DBTextcnpj.Caption, '.', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '/', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '-', '', [rfReplaceAll]);

    PastaDestino := 'C:\XMLSERVSIC\XMLTEMP_CONSULTA_' + FormatDateTime('yyyymmdd', Now) + '\';
    ForceDirectories(PastaDestino);

    Application.ProcessMessages;

    // Prepara o cabeçalho do relatório TXT
    LinhaTXT.Add('RELATORIO DE XMLS DA CONSULTA POR NOTA/PERÍODO');
    LinhaTXT.Add('Empresa: ' + RazaoSocial + ' - CNPJ: ' + CNPJ);
    LinhaTXT.Add(Format('Total de registros na grade: %d', [DataModule1.QRYNOTAPERDIDA.RecordCount]));
    LinhaTXT.Add('');

    // Move para o primeiro registro e desabilita controles para performance
    DataModule1.QRYNOTAPERDIDA.DisableControls;
    DataModule1.QRYNOTAPERDIDA.First;

    // 2. ITERAÇÃO SOBRE TODOS OS REGISTROS DA CONSULTA
    while not DataModule1.QRYNOTAPERDIDA.Eof do
    begin
      Inc(Contador);

      // Reinicia o XML para o novo ciclo
      XMLTextoSalvar := '';

      // 2.1. Coleta das chaves do registro atual
      with DataModule1.QRYNOTAPERDIDA do
      begin
        NumNota := FieldByName('num_nota_fiscal').AsString;
        Serie := FieldByName('Num_Serie').AsString;
        Modelo := FieldByName('Num_Mod_Doc').AsString;
        StatusNota := FieldByName('St_Retorno').AsString;
      end;

      // 2.2. BUSCA NA NFE_XML (COM FOCO NO DOCUMENTO FISCAL FINAL)
      with DataModule1.QRYVERIFICANFE_XML do
      begin
        Close;
        SQL.Text := 'SELECT XMLTransmissao, XMLInutilizacao, XMLGeracao FROM NFE_XML WHERE NumNota = :numnota AND Serie = :serie AND Num_Mod_Doc = :modelo';
        ParamByName('numnota').AsString := NumNota;
        ParamByName('serie').AsString := Serie;
        ParamByName('modelo').AsString := Modelo;
        Open;

        if not IsEmpty then
        begin
          // PRIORIDADE 1: XMLTransmissao (Documento Final Autorizado/Cancelado - <nfeProc>)
          XMLTextoSalvar := FieldByName('XMLTransmissao').AsString;

          // PRIORIDADE 2: XMLInutilizacao (Documento de Inutilização)
          if (XMLTextoSalvar = '') and (FieldByName('XMLInutilizacao').AsString <> '') then
            XMLTextoSalvar := FieldByName('XMLInutilizacao').AsString;

          // PRIORIDADE 3: XMLGeracao (XML Assinado, último recurso se não houver protocolo/inutilização)
          if (XMLTextoSalvar = '') and (FieldByName('XMLGeracao').AsString <> '') then
            XMLTextoSalvar := FieldByName('XMLGeracao').AsString;
        end;

        Close;
      end;

      // 2.3. Se não encontrou, tenta buscar na SERVXML (Inutilização)
      if XMLTextoSalvar = '' then
      begin
        with DataModule1.QRYINSERESERVXML do
        begin
          Close;
          SQL.Text := 'SELECT XMLTransmissao FROM SERVXML WHERE NumNota = :numnota AND Serie = :serie AND Num_Mod_Doc = :modelo';
          ParamByName('numnota').AsString := NumNota;
          ParamByName('serie').AsString := Serie;
          ParamByName('modelo').AsString := Modelo;
          Open;

          if not IsEmpty then
            XMLTextoSalvar := FieldByName('XMLTransmissao').AsString;

          Close;
        end;
      end;


      // 2.4. Salvar o arquivo XML (se encontrado)
      if XMLTextoSalvar <> '' then
      begin
        // Cria o nome do arquivo com base nos dados da nota e status
        NomeArquivo := Format('XML_Nota_%s_S%s_M%s_%s_COMPLETO.xml', [NumNota, Serie, Modelo, StringReplace(StatusNota, ' ', '_', [rfReplaceAll])]);
        CaminhoCompleto := IncludeTrailingPathDelimiter(PastaDestino) + NomeArquivo;

        XMLContent.Text := XMLTextoSalvar;
        XMLContent.SaveToFile(CaminhoCompleto);

        LinhaTXT.Add(Format('Nota: %s | Série: %s | Modelo: %s | Status: %s | Arquivo: %s', [NumNota, Serie, Modelo, StatusNota, NomeArquivo]));
      end
      else
      begin
        LinhaTXT.Add(Format('Nota: %s | Aviso: Conteúdo XML NÃO COMPLETO encontrado. Status BD: %s', [NumNota, StatusNota]));
      end;

      DataModule1.QRYNOTAPERDIDA.Next; // AVANÇA PARA O PRÓXIMO REGISTRO
    end; // Fim do while

    // Salva o relatório TXT
    LinhaTXT.SaveToFile(PastaDestino + 'Relatorio_XMLs_Consultados.txt');

    // Cria o nome do arquivo ZIP
    NomeArquivoZip := Format('C:\XMLSERVSIC\%s_%s_XMLS_CONSULTA_FISCAL.zip', [
      StringReplace(CNPJ, ' ', '', [rfReplaceAll]),
      FormatDateTime('YYYYMMDD_HHNN', Now)
    ]);

    // Compacta os arquivos
    ZipFile.Open(NomeArquivoZip, zmWrite);
    try
      // Adiciona todos os XMLs e o relatório TXT ao ZIP
      for CaminhoArquivo in TDirectory.GetFiles(PastaDestino, '*', TSearchOption.soTopDirectoryOnly) do
        ZipFile.Add(CaminhoArquivo, ExtractFileName(CaminhoArquivo));
    finally
      ZipFile.Close;
    end;

    ShowMessage(Format('Processo concluído! %d XMLs salvos e compactados em: %s', [Contador, NomeArquivoZip]));

  finally
    DataModule1.QRYNOTAPERDIDA.EnableControls;
    XMLContent.Free;
    LinhaTXT.Free;
    FreeAndNil(ZipFile);

    // Limpa a pasta temporária
    if DirectoryExists(PastaDestino) then TDirectory.Delete(PastaDestino, True);

    Application.ProcessMessages;
  end;
end;




procedure Tfrmmenu.ExportarXMLsMesAnterior;
var
  PastaBase, PastaNFE, PastaNFCE: String;
  RazaoSocial, CNPJ, NomeArquivo: String;
  DataInicio, DataFim: TDate;
  DataFimComHora: TDateTime;
  CodEmitente: Integer;

  CaminhoArquivo, ArquivoXML, StatusNota: String;
  NomeArquivoZip: String;

  ZipFile: TZipFile;
  Contador: Integer;

begin
  // Inicializa objetos
  ZipFile := nil;
  Contador := 0;

  // --- 0. EXIBIR FORMULÁRIO DE ESPERA ---
  if not Assigned(FRMESPERA) then
    FRMESPERA := TFRMESPERA.Create(Self);

  FRMESPERA.Label1.Caption := 'Preparando a exportação de XMLs...';
  FRMESPERA.Position := poScreenCenter;
  FRMESPERA.Show;
  Application.ProcessMessages;

  try
    // --- 1. OBTENDO EMITENTE E PARÂMETROS ---
    if cmbempresa.ItemIndex = -1 then
    begin
      ShowMessage(' Erro: Nenhuma empresa (emitente) selecionada. Exportação cancelada.');
      Exit;
    end;
    CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

    // Coleta dados do emitente e Datas
    DataModule1.QRYEMITENTE.Close;
    DataModule1.QRYEMITENTE.SQL.Text := 'SELECT Razao_Social, CNPJ FROM NFE_EMITENTE WHERE Codigo = :Codigo';
    DataModule1.QRYEMITENTE.ParamByName('Codigo').AsInteger := CodEmitente;
    DataModule1.QRYEMITENTE.Open;

    if DataModule1.QRYEMITENTE.IsEmpty then
    begin
      ShowMessage(' Erro: Dados do emitente não encontrados. Exportação cancelada.');
      Exit;
    end;

    // Assegurando que CNPJ esteja limpo para o nome do arquivo
    RazaoSocial := DataModule1.QRYEMITENTE.FieldByName('Razao_Social').AsString;
    CNPJ := DataModule1.QRYEMITENTE.FieldByName('CNPJ').AsString;
    CNPJ := StringReplace(CNPJ, '.', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '/', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '-', '', [rfReplaceAll]);

    DataModule1.QRYEMITENTE.Close; // <-- FECHA QRYEMITENTE APÓS USO

    DataInicio := DTinicio.Date;
    DataFim := DTfim.Date;
    DataFimComHora := DataFim + (23/24) + (59/(24*60)) + (59/(24*60*60));

    // --- 2. CONFIGURANDO PASTAS DE DESTINO ---
    FRMESPERA.Label1.Caption := 'Configurando pastas e consultando dados...';
    Application.ProcessMessages;

    // Pasta Base: C:\XMLSERVSIC\XML\
    PastaBase := 'C:\XMLSERVSIC\XML\';
    PastaNFE := PastaBase + 'NFE\'; // NFE_55
    PastaNFCE := PastaBase + 'NFCE\'; // NFCE_65

    ForceDirectories(PastaNFE);
    ForceDirectories(PastaNFCE);

    // =========================================================================
    // BLOCO A: CONSULTA E SALVAMENTO CONSOLIDADO (NFE_XML)
    // =========================================================================
    FRMESPERA.Label1.Caption := 'Buscando XMLs na NFE_XML...';
    Application.ProcessMessages;

    with DataModule1.QRYSALVAARQXML do
    begin
        Close;
        SQL.Clear;
        SQL.Text :=
          'SELECT nx.XMLTransmissao, nx.xmlchave, nx.NumNota, nx.Serie, nx.Num_Mod_Doc, nx.Status ' +
          'FROM nfe_xml nx ' +
          'WHERE nx.CodEmitente = :P_CodEmitente ' +
          'AND nx.Data_Emissao BETWEEN :DataInicio AND :DataFim ' +
          'AND nx.Num_Mod_Doc IN (55, 65) ' +
          'AND nx.Status IN (''T'', ''C'', ''I'') ' +
          'ORDER BY nx.Num_Mod_Doc, nx.NumNota';

        ParamByName('P_CodEmitente').AsInteger := CodEmitente;
        ParamByName('DataInicio').AsDateTime := DataInicio;
        ParamByName('DataFim').AsDateTime := DataFimComHora;
        Open;

        while not Eof do
        begin
          ArquivoXML := FieldByName('XMLTransmissao').AsString;

          if ArquivoXML <> '' then
          begin
            Inc(Contador);
            StatusNota := FieldByName('Status').AsString;

            NomeArquivo := Format('%s_N%s_S%s_M%s_St%s.xml', [
              FieldByName('xmlchave').AsString,
              FieldByName('NumNota').AsString,
              FieldByName('Serie').AsString,
              FieldByName('Num_Mod_Doc').AsString,
              StatusNota]);

            // --- ESCOLHE PASTA COM BASE NO MODELO ---
            if FieldByName('Num_Mod_Doc').AsInteger = 55 then
              CaminhoArquivo := PastaNFE + NomeArquivo
            else
              CaminhoArquivo := PastaNFCE + NomeArquivo;

            // Salva o XML (Usando um TStringList temporário)
            with TStringList.Create do
            try
              Text := ArquivoXML;
              SaveToFile(CaminhoArquivo);
            finally
              Free;
            end;
          end;

          Next;
        end;
        Close; // <-- FECHA A QUERY AQUI
    end;


    // =========================================================================
    // BLOCO B: INUTILIZAÇÃO COMPLEMENTAR (SERVXML)
    // =========================================================================
    FRMESPERA.Label1.Caption := 'Buscando XMLs de inutilização na SERVXML...';
    Application.ProcessMessages;

    with DataModule1.QRYBUSCARSALVADORES do
    begin
        Close;
        SQL.Clear;
        SQL.Text :=
          'SELECT XMLTransmissao, NumNota, Num_Mod_Doc, Serie FROM SERVXML ' +
          'WHERE CodEmitente = :P_CodEmitente ' +
          'AND Data_Emissao >= :DataInicio AND Data_Emissao <= :DataFim ' +
          'AND Status = ''I'' ' +
          'ORDER BY NumNota';

        ParamByName('P_CodEmitente').AsInteger := CodEmitente;
        ParamByName('DataInicio').AsDateTime := DataInicio;
        ParamByName('DataFim').AsDateTime := DataFimComHora;
        Open;

        while not Eof do
        begin
          ArquivoXML := FieldByName('XMLTransmissao').AsString;

          if ArquivoXML <> '' then
          begin
            Inc(Contador);
            NomeArquivo := Format('INUT_N%s_S%s_M%s_SERVXML.xml', [
              FieldByName('NumNota').AsString,
              FieldByName('Serie').AsString,
              FieldByName('Num_Mod_Doc').AsString]);

            // Salva na PASTA DE DESTINO CORRESPONDENTE AO MODELO
            if FieldByName('Num_Mod_Doc').AsInteger = 55 then
              CaminhoArquivo := PastaNFE + NomeArquivo
            else
              CaminhoArquivo := PastaNFCE + NomeArquivo;

            // Salva o XML (Usando um TStringList temporário)
            with TStringList.Create do
            try
              Text := ArquivoXML;
              SaveToFile(CaminhoArquivo);
            finally
              Free;
            end;
          end;
          Next;
        end;
        Close; // <-- FECHA A QUERY AQUI
    end;


    // --- 4. FINALIZAÇÃO E COMPACTAÇÃO ---
    FRMESPERA.Label1.Caption := Format('Compactando %d arquivos. Aguarde...', [Contador]);
    Application.ProcessMessages;

    // Nomenclatura do arquivo ZIP salva na PastaBase com CNPJ, Razão Social e Período
    NomeArquivoZip := Format('%s%s_%s__DE%s_A%s.zip', [
      PastaBase,
      CNPJ,
      StringReplace(RazaoSocial, ' ', '_', [rfReplaceAll]),
      FormatDateTime('YYYYMMDD', DataInicio),
      FormatDateTime('YYYYMMDD', DataFim)
    ]);

    ZipFile := TZipFile.Create;
    try
      ZipFile.Open(NomeArquivoZip, zmWrite);

      // Adiciona todos os arquivos das pastas NFE e NFCE
      for CaminhoArquivo in TDirectory.GetFiles(PastaNFE, '*', TSearchOption.soTopDirectoryOnly) do
        ZipFile.Add(CaminhoArquivo, 'NFE\' + ExtractFileName(CaminhoArquivo));

      for CaminhoArquivo in TDirectory.GetFiles(PastaNFCE, '*', TSearchOption.soTopDirectoryOnly) do
        ZipFile.Add(CaminhoArquivo, 'NFCE\' + ExtractFileName(CaminhoArquivo));

    finally
      if Assigned(ZipFile) then ZipFile.Close;
    end;

    // Limpeza de pastas temporárias
    if DirectoryExists(PastaNFE) then TDirectory.Delete(PastaNFE, True);
    if DirectoryExists(PastaNFCE) then TDirectory.Delete(PastaNFCE, True);

    ShowMessage(Format('✅ Exportação concluída! %d arquivos XMLs salvos e compactados em: %s', [Contador, NomeArquivoZip]));

  except
    on E: Exception do
    begin
      ShowMessage(' Erro FATAL na exportação dos XMLs: ' + E.Message);
    end;
 end;
    // --- FINALIZAÇÃO DO FRMESPERA E LIBERAÇÃO DE RECURSOS ---

    // Fechamento Garantido de Todas as Queries do DataModule no Final
    if Assigned(DataModule1.QRYEMITENTE) and DataModule1.QRYEMITENTE.Active then
        DataModule1.QRYEMITENTE.Close;

    if Assigned(DataModule1.QRYBUSCARSALVADORES) and DataModule1.QRYBUSCARSALVADORES.Active then
        DataModule1.QRYBUSCARSALVADORES.Close;

    if Assigned(DataModule1.QRYSALVAARQXML) and DataModule1.QRYSALVAARQXML.Active then
        DataModule1.QRYSALVAARQXML.Close;

    if Assigned(FRMESPERA) then FRMESPERA.Hide;
    if Assigned(ZipFile) then ZipFile.Free;

  end;










procedure Tfrmmenu.btnveriinutilizaClick(Sender: TObject);
begin
  // Esta procedure inicia o ciclo completo de Auditoria, que consulta
  // a SEFAZ para todas as notas pendentes e corrige o status 102.
  AuditarNotaSEFAZ;

  // Após a auditoria, a lista de pendentes deve ser atualizada.
  ConsultarVendasPendentes;
  ApagarArquivosXMLTemp;

end;

procedure Tfrmmenu.btnxmllistaClick(Sender: TObject);
begin
SalvarXMLsInutilizadosEUtilizados;
end;

// ATENÇÃO: Esta é a procedure do antigo Button2.
// Ela agora apenas exibirá uma mensagem informativa, pois a função principal
// de importar TXT foi movida para btnimportarClick.
procedure Tfrmmenu.btninutilizaespcClick(Sender: TObject);
begin
  // --- VALIDAÇÃO: Verificar se um emitente está selecionado ---
  if cmbempresa.ItemIndex = -1 then
  begin
    memoemail.Lines.Add('⚠️ Selecione uma empresa (emitente) antes de realizar a inutilização!');
    ShowMessage('⚠️ Por favor, selecione uma empresa (emitente) na lista antes de prosseguir.');
    Exit; // Sai da procedure se nenhum emitente estiver selecionado
  end;

  // Aciona a procedure btnInutilizarClick do formulário frmACBrNFe
  // O 'Sender' é passado para simular um clique vindo do Button1
  frmACBrNFe.btnInutilizarClick(Sender);
end;



procedure Tfrmmenu.btnlimpalistaClick(Sender: TObject);
begin
LimparCDSQuebra;
end;

procedure Tfrmmenu.btnlimpavendaClick(Sender: TObject);
var
  Pedido: Integer;
  EsperaForm: TfrmEspera;
  TotalPedidos, PedidoAtual: Integer;
begin
  MemoEmail.Lines.Clear;
  MemoEmail.Lines.Add('Iniciando processo de limpeza de registros pendentes...');
  Application.ProcessMessages;

  if not DataModule1.QRYCARREGAVENDAS.Active or DataModule1.QRYCARREGAVENDAS.IsEmpty then
  begin
    ShowMessage('Nenhum pedido encontrado para limpar. Execute a consulta de vendas pendentes primeiro!');
    Exit;
  end;

  // Inicializa o Form de Espera
  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    TotalPedidos := DataModule1.QRYCARREGAVENDAS.RecordCount;
    EsperaForm.Label1.Caption := Format('Preparando limpeza de %d pedidos...', [TotalPedidos]);
    EsperaForm.Show;
    Application.ProcessMessages;

    DataModule1.QRYCARREGAVENDAS.First;
    PedidoAtual := 0;

    while not DataModule1.QRYCARREGAVENDAS.Eof do
    begin
      Inc(PedidoAtual);
      Pedido := DataModule1.QRYCARREGAVENDAS.FieldByName('Pedido').AsInteger;

      EsperaForm.Label1.Caption := Format('Limpando pedido %d... (%d de %d)', [Pedido, PedidoAtual, TotalPedidos]);
      Application.ProcessMessages;

      MemoEmail.Lines.Add(Format('Processando limpeza do pedido: %d', [Pedido]));
      Application.ProcessMessages;

      DataModule1.ConDados.StartTransaction;
      try
        // 1. Limpa TABEST3A
        with DataModule1.QRYLIMPANFCE do
        begin
          Close;
          SQL.Text := 'UPDATE TABEST3A SET NOTA = NULL, SERIE = NULL WHERE PEDIDO = :pedido;';
          ParamByName('pedido').AsInteger := Pedido;
          ExecSQL;
        end;

        // 2. Exclui da NFe_XMLTemp
        with DataModule1.QRYLIMPANFCE do
        begin
          Close;
          SQL.Text := 'DELETE FROM NFe_XMLTemp WHERE codvenda = :pedido;';
          ParamByName('pedido').AsInteger := Pedido;
          ExecSQL;
        end;

        // 3. Exclui da NFe_XML
        with DataModule1.QRYLIMPANFCE do
        begin
          Close;
          SQL.Text := 'DELETE FROM NFe_XML WHERE pedido = :pedido;';
          ParamByName('pedido').AsInteger := Pedido;
          ExecSQL;
        end;

        // 4. Exclui da NFe_Cab
        with DataModule1.QRYLIMPANFCE do
        begin
          Close;
          SQL.Text := 'DELETE FROM NFe_Cab WHERE codVENDA = :pedido;';
          ParamByName('pedido').AsInteger := Pedido;
          ExecSQL;
        end;

        DataModule1.ConDados.Commit;
        MemoEmail.Lines.Add(Format('? Pedido %d limpo com sucesso!', [Pedido]));
      except
        on E: Exception do
        begin
          DataModule1.ConDados.Rollback;
          MemoEmail.Lines.Add(Format('? Erro ao limpar pedido %d: %s', [Pedido, E.Message]));
          ShowMessage('Erro ao limpar pedido ' + IntToStr(Pedido) + ': ' + E.Message);
          Exit;
        end;
      end;

      DataModule1.QRYCARREGAVENDAS.Next;
    end;

    MemoEmail.Lines.Add('? Processo de limpeza concluído com sucesso!');
    ShowMessage('? Processo de limpeza concluído com sucesso!');
  finally
    if Assigned(EsperaForm) then
      FreeAndNil(EsperaForm);
  end;

  // Atualiza a grade de pendentes
  brnconsultavendaClick(Sender);
end;






procedure Tfrmmenu.btnlistanaousadaClick(Sender: TObject);
var
  CodEmitente: Integer;
  DataInicio, DataFimComHora: TDateTime;
begin
  // Limpa o log e mensagens
  MemoConsulta.Clear;

  // 1. **VALIDAÇÃO E PARÂMETROS**
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('❌ Selecione a empresa emitente.');
    Exit;
  end;

  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
  DataInicio := DTinicio.Date;
  // Ajusta a data final para incluir o dia inteiro
  DataFimComHora := DTfim.Date + (23/24) + (59/(24*60)) + (59/(24*60*60));

  try
    // 2. **CONFIGURAÇÃO DO CDSQUEBRA** (Reutilizando a estrutura necessária)
    LimparCDSQuebra; // Garante que a estrutura básica esteja pronta [cite: 641, 642, 643, 644, 645]

    // 3. **EXECUÇÃO DA CONSULTA (QRYNAOUSADOSPORDATA)**
    with DataModule1.QRYNAOUSADOSPORDATA do
    begin
      Close;
      SQL.Clear;

      // Seleciona as colunas necessárias para o CDSQUEBRA
      SQL.Add('SELECT XT.CodNota, XT.CodEmitente, ');
      SQL.Add('       XT.Num_Nota_Fiscal AS NumNota, ');
      SQL.Add('       XT.Num_Serie AS Serie, ');
      SQL.Add('       NC.Num_Mod_Doc, ');
      SQL.Add('       XT.DataCriacao AS Data_Emissao ');
      SQL.Add('FROM NFE_XMLTemp XT ');
      // JOIN com NFE_CAB para obter Num_Mod_Doc e garantir que a nota foi gerada (CodNota)
      SQL.Add('JOIN NFE_CAB NC ON NC.Num_Nota_Fiscal = XT.Num_Nota_Fiscal ');
      SQL.Add('  AND NC.CodEmitente = XT.CodEmitente ');

      // Filtros Essenciais: Data, Emitente e Status "Não Utilizada"
      SQL.Add('WHERE XT.DataCriacao BETWEEN :pDataInicio AND :pDataFimComHora ');
      SQL.Add('  AND XT.CodEmitente = :pCodEmitente ');
      // A) Deve ter Tipo de Emissão 1 (Normal) - Usando LIKE para procurar no XML
      SQL.Add('  AND XT.XMLTexto LIKE ''%<tpEmis>1</tpEmis>%'' ');
      // B) Não deve ter Protocolo de Autorização (indicando que falhou e não está na NFE_XML principal como T)
      SQL.Add('  AND XT.XMLTexto NOT LIKE ''%<nProt>%'' ');
      SQL.Add('ORDER BY XT.Num_Nota_Fiscal');

      // Parâmetros
      ParamByName('pCodEmitente').AsInteger := CodEmitente;
      ParamByName('pDataInicio').AsDateTime := DataInicio;
      ParamByName('pDataFimComHora').AsDateTime := DataFimComHora;

      Open;

      // 4. **CARREGAMENTO PARA O CDSQUEBRA**
      if not IsEmpty then
      begin
        DisableControls;
        First;
        while not Eof do
        begin
          CDSQUEBRA.Append;
          // Preenche os campos do CDSQUEBRA com os dados do QRYNAOUSADOSPORDATA
          CDSQUEBRA.FieldByName('CodNota').Assign(FieldByName('CodNota'));
          CDSQUEBRA.FieldByName('CodEmitente').Assign(FieldByName('CodEmitente'));
          CDSQUEBRA.FieldByName('Num_Mod_Doc').Assign(FieldByName('Num_Mod_Doc'));
          CDSQUEBRA.FieldByName('Serie').Assign(FieldByName('Serie'));
          CDSQUEBRA.FieldByName('NumNota').Assign(FieldByName('NumNota'));
          CDSQUEBRA.FieldByName('Data_Emissao').Assign(FieldByName('Data_Emissao'));
          CDSQUEBRA.Post;
          Next;
        end;
        EnableControls;
      end;
    end;

    // 5. **FEEDBACK**
    contaregistrosfaltantes; // Atualiza o label Labelfaltantes [cite: 438]

    if CDSQUEBRA.IsEmpty then
    begin
      MemoConsulta.Lines.Add('✅ Nenhuma nota não utilizada foi encontrada no período selecionado.');
      ShowMessage('Busca concluída. Nenhuma nota encontrada.');
    end
    else
    begin
      MemoConsulta.Lines.Add(Format('✅ Busca concluída. %d notas não utilizadas (tpEmis=1 sem protocolo) foram adicionadas à lista de inutilização.', [CDSQUEBRA.RecordCount]));
      ShowMessage(Format('Busca concluída! %d notas adicionadas à lista.', [CDSQUEBRA.RecordCount]));
      opcoes.ActivePage := Inutilizar; // Move para a aba de inutilização [cite: 12]
    end;

  except
    on E: Exception do
    begin
      MemoConsulta.Lines.Add('❌ ERRO ao executar a consulta: ' + E.Message);
      ShowMessage('❌ Erro na consulta: ' + E.Message);
    end;
  end;
end;




procedure Tfrmmenu.BTNLMPLISTACONSULTAClick(Sender: TObject);
begin

  if DataModule1.CDSCONSULTACHAVE.Active then
    DataModule1.CDSCONSULTACHAVE.Close;



  // Limpa as definições de campo (estrutura).
  DataModule1.CDSCONSULTACHAVE.FieldDefs.Clear;


  MemoConsulta.Lines.Clear;


end;

procedure Tfrmmenu.btnlimpalogClick(Sender: TObject);
begin
 MemoEmail.Clear;
end;





procedure Tfrmmenu.btnalteraxmlClick(Sender: TObject);
var
  EsperaForm: TfrmEspera;
begin
  // 1. INICIALIZAÇÃO E EXIBIÇÃO DO FORM DE ESPERA
  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Label1.Caption := 'Processando e Corrigindo XMLs no Banco de Dados...';
    EsperaForm.Show;
    Application.ProcessMessages;

    // --- 2. EXECUÇÃO DA TAREFA PESADA ---
     AtualizarChavesCorretas;
    // PASSO 1: CORREÇÃO DE CHAVES INCONSISTENTES (ERRO 613)
    // Isso garante que a Chave de Acesso no XML e no BD estejam sincronizadas antes de modificar o XML.
    EsperaForm.Label1.Caption := '1/2: Corrigindo Chaves de Acesso Inconsistentes (613)...';
    Application.ProcessMessages;


    // PASSO 2: CORREÇÃO GERAL DO XML E SALVAMENTO (Remoção de tags, ajuste de NCM/PIX, etc.)
    EsperaForm.Label1.Caption := '2/2: Corrigindo Estrutura e Campos do XML (dhEmi, NCM, etc.)...';
    Application.ProcessMessages;

    ModificarESalvarXMLGeracao


  finally
    // 3. FINALIZAÇÃO E LIMPEZA
    if Assigned(EsperaForm) then
    begin
      EsperaForm.Close;
      EsperaForm.Free;
    end;
  end;

  // Após a correção, recarregamos a lista para refletir os ajustes.
  ConsultarVendasPendentes;
  ShowMessage('✅ Correção de XMLs concluída. Notas prontas para o reenvio.');
end;



procedure Tfrmmenu.btnatualizabancoClick(Sender: TObject);
var
  EsperaForm: TFRMESPERA;
begin
  // 1. Cria e exibe o Form de Espera
  EsperaForm := TFRMESPERA.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Label1.Caption := 'Executando correções no banco de dados. Aguarde...';
    EsperaForm.Show;
    Application.ProcessMessages; // Força a exibição imediata do form.

    EsperaForm.Label1.Caption := 'Corrigindo dados...';
    Application.ProcessMessages;




    // 2. Execução das ações de banco
    EsperaForm.Label1.Caption := 'Atualizando registros...';
    Application.ProcessMessages;
   CriarTabelaSERVXML;
   corrigirdados;
   ForcarMigracaoXMLTemp;
   UPDATEBANCO;
   CorrigirPendenciasBaseadoEmServxml;
   ExecutarUpdateNotasFiscais;
  






  finally
    // 3. Fecha e libera o Form de Espera
    if Assigned(EsperaForm) then
      FreeAndNil(EsperaForm);
  end;
end;



procedure Tfrmmenu.btnbuscarClick(Sender: TObject);
begin
ConsultarNotaPerdida;
end;

procedure Tfrmmenu.btnconsultasefazClick(Sender: TObject);
begin
  ShellExecute(Handle, 'open', 'https://app.sefa.pa.gov.br/consulta-nfce/#/consulta', nil, nil, SW_SHOWNORMAL);
end;

procedure Tfrmmenu.BTNALTERARNUMNFCEClick(Sender: TObject);
begin
PularProximaNumeracaoNFCe;
end;

procedure Tfrmmenu.CarregarEmitentes;
var
  CodigoEmitente, CNPJEmitente: String;
begin
  try
    cmbempresa.Clear;

    with DataModule1.QRYEMITENTE do
    begin
      Close;
      SQL.Text := 'SELECT Codigo, CNPJ FROM NFe_Emitente ORDER BY Codigo';
      Open;

      while not Eof do
      begin
        CodigoEmitente := FieldByName('Codigo').AsString;
        CNPJEmitente := FieldByName('CNPJ').AsString;

        // Adiciona "Código - CNPJ" ao ComboBox
        cmbempresa.Items.AddObject(CodigoEmitente + ' - ' + CNPJEmitente,
          TObject(FieldByName('Codigo').AsInteger));

        Next;
      end;
    end;

    // Removendo a seleção automática
    cmbempresa.ItemIndex := -1;

  except
    ShowMessage('Erro ao carregar emitentes!');
  end;
end;

// ATENÇÃO: Esta é a procedure auxiliar ProcessarIntervaloNotas.
// Ela agora apenas adiciona os dados ao CDSQUEBRA, sem consultas ao banco aqui.
procedure Tfrmmenu.ProcessarIntervaloNotas(ACodEmitente, AModelo, ASerie: Integer; ADataEmissao: TDateTime; ANotaInicial, ANotaFinal: Integer);
var
  i: Integer;
begin
  for i := ANotaInicial to ANotaFinal do
  begin
    CDSQUEBRA.Append;
    CDSQUEBRA.FieldByName('CodNota').AsInteger := i;
    CDSQUEBRA.FieldByName('CodEmitente').AsInteger := ACodEmitente;
    CDSQUEBRA.FieldByName('Num_Mod_Doc').AsInteger := AModelo;
    CDSQUEBRA.FieldByName('Serie').AsInteger := ASerie;
    CDSQUEBRA.FieldByName('NumNota').AsInteger := i;
    CDSQUEBRA.FieldByName('Data_Emissao').AsDateTime := ADataEmissao;
    CDSQUEBRA.Post;
  end;
end;

procedure Tfrmmenu.cmbempresaChange(Sender: TObject);
begin
  Selecionaemitente;
  frmACBrNFe.sbtnGetCertClick(Sender);
  frmACBrNFe.btnSalvarConfigClick(Sender);
end;







procedure Tfrmmenu.contaregistrosfaltantes;
begin
  Labelfaltantes.Caption := 'Total de Registros: ' + IntToStr(DBGridFaltante.DataSource.DataSet.RecordCount);
end;

procedure Tfrmmenu.CMBMODELOChange(Sender: TObject);
var
Modelo: Integer;

begin
CarregarSeriesEmitidas(Modelo);
end;

procedure Tfrmmenu.ConsultarValorEmitido;
var
  CodigoEmitente: Integer;
  DataInicio, DataFim: TDateTime;
  ValorTotal: Double;
begin
  // 🔹 **Verifica se um emitente foi selecionado**
  if (cmbempresa.ItemIndex = -1) or (not Assigned(DataModule1.QRYBUSCARVALOR)) then
  begin
    ShowMessage('❌ Selecione um emitente antes de consultar o valor!');
    Exit;
  end;

  // 🔹 **Obtém os parâmetros de filtro**
  CodigoEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
  DataInicio := dtinicio.Date;
  DataFim := dtfim.Date;

  // 🔹 **Valida o período**
  if DataInicio > DataFim then
  begin
    ShowMessage('❌ Data inicial não pode ser maior que a data final!');
    Exit;
  end;

  try
    with DataModule1.QRYBUSCARVALOR do
    begin
      Close;
      SQL.Clear;
      SQL.Text := 'SELECT SUM(C.Valor_Total_Nota) AS ValorTotalEmitido ' +
                  'FROM NFE_XML X ' +
                  'JOIN NFE_CAB C ON X.CodNota = C.CodNota AND X.CodEmitente = C.CodEmitente ' +
                  'WHERE X.CodEmitente = :CodEmitente ' +
                  'AND CAST(X.Data_Emissao AS DATE) BETWEEN :DataInicio AND :DataFim ' +
                  'AND X.Status = ''T'' ' +
                  'AND (C.Num_Mod_Doc <> 55 OR C.CFOP IN (''5101'', ''5102'', ''5405'', ''6101'', ''6102'', ''6405''))';

      // 🔹 **Passa os parâmetros corretamente**
      ParamByName('CodEmitente').AsInteger := CodigoEmitente;
      ParamByName('DataInicio').AsDateTime := DataInicio;
      ParamByName('DataFim').AsDateTime := DataFim;

      Open;

      // 🔹 **Obtém o valor total e exibe na label**
      ValorTotal := FieldByName('ValorTotalEmitido').AsFloat;
      if FieldByName('ValorTotalEmitido').IsNull then
        ValorTotal := 0;


    end;

  except
    on E: Exception do
      ShowMessage('❌ Erro ao consultar o valor emitido: ' + E.Message);
  end;
end;









procedure Tfrmmenu.ApagarArquivosXMLTemp;
const
  PASTA_TEMP = 'C:\XMLSERVSIC\XMLTEMP';
begin
  // A classe TDirectory está disponível na unit System.IOUtils
  // (A unit System.IOUtils está listada na interface da sua unit GERAXML )
  try
    if TDirectory.Exists(PASTA_TEMP) then
    begin
      // TDirectory.Delete apaga o diretório especificado
      // O segundo parâmetro (True) indica que a exclusão deve ser recursiva (incluindo subpastas e arquivos).
      TDirectory.Delete(PASTA_TEMP, True);

      // O comando acima exclui a própria pasta XMLTEMP, então a recriamos vazia.
      ForceDirectories(PASTA_TEMP);
    end;
  except
    on E: Exception do
    begin
      // Você pode logar o erro aqui, mas evite travar o processo principal
      // se a exclusão falhar devido a arquivos em uso, por exemplo.
      // MemoEmail.Lines.Add('⚠️ Erro ao tentar limpar a pasta temporária: ' + E.Message);
    end;
  end;
end;






procedure Tfrmmenu.EnviarXMLPorEmail;
var
  // Variáveis para a coleta de dados (UI)
  NomeArquivoZip, TituloEmail, DataInicioStr, DataFimStr: String;
  DataInicio, DataFim: TDate;
  RazaoSocialEmpresa, CNPJEmpresa: String;

  // Variáveis capturadas para a função
  _NomeArquivoZip: String;
  _TituloEmail: String;
  _EmailDestinatario: String;
  _CorpoEmail: String;

  Attachment: TIdAttachmentFile;
begin
  // **********************************************
  // 1. INICIALIZAÇÃO E COLETA DE DADOS (RÁPIDO)
  // **********************************************

  // Cria o form espera se não existir (mas não mostra ainda)
  if not Assigned(FRMESPERA) then
    FRMESPERA := TFRMESPERA.Create(Self);

  MemoEmail.Clear;
  MemoEmail.Lines.Add('Preparando para enviar o e-mail de XMLs...');
  Application.ProcessMessages;

  // ... (Coleta de Datas, Empresa e Seleção do Arquivo ZIP - Lógica Omitida para Foco) ...
  // Supondo que a lógica anterior de coleta e seleção do arquivo ZIP
  // (incluindo a manipulação da QRYEMITENTE e OpenDialog1)
  // foi executada aqui e o 'NomeArquivoZip' foi obtido/validado com sucesso.

  // ** INÍCIO DA LÓGICA DE SELEÇÃO E VALIDAÇÃO **
  DataInicio := EncodeDate(YearOf(Date), MonthOf(Date) - 1, 1);
  DataFim := EndOfTheMonth(DataInicio);
  DataInicioStr := FormatDateTime('DD/MM/YYYY', DataInicio);
  DataFimStr := FormatDateTime('DD/MM/YYYY', DataFim);

  // Busca dados da empresa (Adapte este bloco se for necessário)
  RazaoSocialEmpresa := 'Empresa Emitente';
  CNPJEmpresa := '00000000000000';

  // Configuração do OpenDialog (necessária para a execução)
  OpenDialog1.Filter := 'Arquivos ZIP (*.zip)|*.zip|Todos os Arquivos (*.*)|*.*';
  OpenDialog1.Title := 'Selecione o arquivo ZIP com os XMLs para enviar';
  OpenDialog1.Options := [ofFileMustExist, ofEnableSizing];

  if DirectoryExists(IncludeTrailingPathDelimiter(frmACBrNFe.edtPathPDF.Text)) then
    OpenDialog1.InitialDir := IncludeTrailingPathDelimiter(frmACBrNFe.edtPathPDF.Text)
  else
    OpenDialog1.InitialDir := GetCurrentDir;

  MemoEmail.Lines.Add('Aguardando seleção do arquivo ZIP...');
  Application.ProcessMessages;

  if not OpenDialog1.Execute then
  begin
    MemoEmail.Lines.Add('❌ Envio cancelado pelo usuário.');
    ShowMessage('Envio de e-mail cancelado.');
    Exit;
  end;

  NomeArquivoZip := OpenDialog1.FileName;

  if not FileExists(NomeArquivoZip) then
  begin
    MemoEmail.Lines.Add('❌ Erro: Arquivo ZIP não encontrado: ' + NomeArquivoZip);
    ShowMessage('❌ O arquivo selecionado não foi encontrado ou foi movido: ' + NomeArquivoZip);
    Exit;
  end;
  // ** FIM DA LÓGICA DE SELEÇÃO E VALIDAÇÃO **

  // **********************************************
  // 2. EXIBIÇÃO DO FORM ESPERA E ENVIO LENTO (GARGALO)
  // **********************************************

  // 🟢 MOVIDO: Mostra a tela de espera somente após a seleção do arquivo.
  FRMESPERA.Label1.Caption := '📧 Processando envio... Conectando ao servidor SMTP...';
  FRMESPERA.Position := poScreenCenter;
  FRMESPERA.Show;
  Application.ProcessMessages;

  // Captura as variáveis
  _NomeArquivoZip := NomeArquivoZip;
  _TituloEmail := 'Arquivos XML - ' + RazaoSocialEmpresa + ' - ' + CNPJEmpresa + ' - de ' + DataInicioStr + ' a ' + DataFimStr;
  _EmailDestinatario := frmACBrNFe.Editemail.Text + ', atendimento@compuservedobrasil.com';
  _CorpoEmail := 'Segue anexo o arquivo ZIP contendo os XMLs exportados do período de ' + DataInicioStr + ' a ' + DataFimStr + '.';

  try
    // --- LÓGICA DE ENVIO (SÍNCRONA) ---
    MemoEmail.Lines.Add('Configurando mensagem de e-mail...');

    // Configuração do TIdMessage (Limpo na thread principal e OK)
    IdMessage1.Clear;
    IdMessage1.From.Address := 'compuserverxml@gmail.com';
    IdMessage1.Recipients.EmailAddresses := _EmailDestinatario;
    IdMessage1.Subject := _TituloEmail;
    IdMessage1.Body.Text := _CorpoEmail;

    MemoEmail.Lines.Add('Adicionando anexo: ' + ExtractFileName(_NomeArquivoZip) + '...');
    // Adicionando o anexo
    Attachment := TIdAttachmentFile.Create(IdMessage1.MessageParts, _NomeArquivoZip);

    // 🚩 PONTO LENTO 1: CONEXÃO COM O SERVIDOR
    FRMESPERA.Label1.Caption := '🌐 Conectando ao servidor SMTP (Google)...';
    MemoEmail.Lines.Add('Conectando ao servidor SMTP...');
    Application.ProcessMessages;

    try
      // Tenta conectar (ponto de latência de rede)
      IdSMTP1.Connect;

      // 🚩 PONTO LENTO 2: ENVIO REAL DO ARQUIVO
      FRMESPERA.Label1.Caption := '📤 Enviando arquivo ZIP (' + ExtractFileName(_NomeArquivoZip) + ')...';
      MemoEmail.Lines.Add('Enviando e-mail... Isso pode levar alguns instantes.');
      Application.ProcessMessages;

      // Envia o arquivo (ponto de transferência de dados)
      IdSMTP1.Send(IdMessage1);

      MemoEmail.Lines.Add('✅ E-mail enviado com sucesso para ' + frmACBrNFe.Editemail.Text + '!');
      ShowMessage('📧 E-mail enviado com sucesso para ' + frmACBrNFe.Editemail.Text);

    finally
      // Garante a desconexão (Ponto rápido)
      if IdSMTP1.Connected then
        IdSMTP1.Disconnect;
      FRMESPERA.Label1.Caption := '✅ Envio concluído. Desconectado.';
    end;

  except
    on E: Exception do
    begin
      MemoEmail.Lines.Add('❌ Erro durante o envio de e-mail: ' + E.Message);
      ShowMessage('❌ Erro durante o envio de e-mail: ' + E.Message);
    end;
  end;

  // **********************************************
  // 3. FECHAMENTO GARANTIDO
  // **********************************************

    // Garante que a tela seja fechada, mesmo que ocorra um erro
    if Assigned(FRMESPERA) then
        FRMESPERA.Hide;
    Application.ProcessMessages;
  end;










procedure Tfrmmenu.CarregarSeriesEmitidas(Modelo: Integer);
var
  CodigoEmitente: Integer;
  DataInicial, DataFinal: TDateTime;
  IsTodosOsModelos: Boolean;
begin
  cmbserie.Clear;
  cmbserie.Items.Add('TODAS');
  cmbserie.ItemIndex := 0;

  // <<<< NOVO BLOCO DE VERIFICAÇÃO >>>>
  // Se 'TODOS' estiver selecionado no modelo, apenas exibe a opção 'TODAS' na série
  IsTodosOsModelos := (CMBMODELO.Text = 'TODOS');
  if IsTodosOsModelos then
  begin
    Exit; // Sai da procedure sem fazer a consulta ao banco de dados
  end;
  // <<<< FIM DO NOVO BLOCO >>>>


  if (cmbempresa.ItemIndex = -1) or (CMBMODELO.ItemIndex = -1) then
    Exit;

  CodigoEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
  DataInicial := DTinicio.Date;
  DataFinal := DTfim.Date;

  if not IsTodosOsModelos then
    Modelo := StrToInt(Copy(CMBMODELO.Text, 1, Pos(' ', CMBMODELO.Text) - 1));

  try
    DataModule1.QRYSERIE.Close;
    DataModule1.QRYSERIE.SQL.Text := 'SELECT DISTINCT nc.num_serie FROM nfe_cab nc ' +
                                     'WHERE nc.codemitente = :CodEmitente ' +
                                     'AND nc.data_emissao BETWEEN :DataInicio AND :DataFim ';

    DataModule1.QRYSERIE.SQL.Add('AND nc.num_mod_doc = :Modelo ');
    DataModule1.QRYSERIE.SQL.Add('ORDER BY nc.num_serie');

    DataModule1.QRYSERIE.ParamByName('CodEmitente').AsInteger := CodigoEmitente;
    DataModule1.QRYSERIE.ParamByName('DataInicio').AsDateTime := DataInicial;
    DataModule1.QRYSERIE.ParamByName('DataFim').AsDateTime := DataFinal + (23/24) + (59/(24*60)) + (59/(24*60*60));
    DataModule1.QRYSERIE.ParamByName('Modelo').AsInteger := Modelo;

    DataModule1.QRYSERIE.Open;

    while not DataModule1.QRYSERIE.Eof do
    begin
      cmbserie.Items.Add(DataModule1.QRYSERIE.FieldByName('num_serie').AsString);
      DataModule1.QRYSERIE.Next;
    end;
  except
    on E: Exception do
      ShowMessage('Erro ao carregar séries: ' + E.Message);
  end;
end;










procedure Tfrmmenu.CarregarXML;
var
  EsperaForm: TfrmEspera;
  // DECLARAÇÃO COMPLETA DAS VARIÁVEIS LOCAIS
  CodEmitente: Integer;
  DataInicial, DataFinalComHora: TDateTime;
  ModeloParaConsulta, TipoAmbiente: Integer; // TipoAmbiente será fixo em 1
  IsTodosOsModelos, IsTodasAsSeries: Boolean;
  SerieSelecionada: Integer;
begin
  // --- 1. CAPTURA E VALIDAÇÃO DE PRÉ-REQUISITOS ---
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('⚠️ Selecione uma empresa (emitente) antes de buscar os arquivos XML!');
    Exit;
  end;

  if cmbmodelo.ItemIndex = -1 then
  begin
    ShowMessage('⚠️ Por favor, selecione o Modelo do Documento (NFe/NFCe) antes de consultar!');
    Exit;
  end;

  if cmbserie.ItemIndex = -1 then
  begin
    ShowMessage('⚠️ Por favor, selecione a Série do Documento (ou TODAS) antes de consultar!');
    Exit;
  end;

  // Coletar Parâmetros da UI (Capturando para a thread)
  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
  DataInicial := DTinicio.Date;
  DataFinalComHora := DTfim.Date + (23/24) + (59/(24*60)) + (59/(24*60*60));

  // --- AJUSTE AQUI: TIPO AMBIENTE FIXO EM PRODUÇÃO (1) ---
  TipoAmbiente := 1;

  // --- CORREÇÃO DE LÓGICA DO MODELO E SÉRIE ---
  IsTodosOsModelos := (CMBMODELO.Text = 'TODOS');
  if not IsTodosOsModelos then
  begin
    ModeloParaConsulta := StrToIntDef(Copy(CMBMODELO.Text, 1, Pos(' ', CMBMODELO.Text) - 1), 0);
  end
  else
  begin
    ModeloParaConsulta := 0;
  end;

  IsTodasAsSeries := (cmbserie.Text = 'TODAS');
  if not IsTodasAsSeries then
    SerieSelecionada := StrToIntDef(cmbserie.Text, 1)
  else
    SerieSelecionada := 0;
  // --- FIM DA CORREÇÃO DE LÓGICA ---


  // --- 2. EXIBIR FORM DE ESPERA ---
  EsperaForm := TfrmEspera.Create(Application);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Show;
    Application.ProcessMessages;
  except
    EsperaForm := nil;
  end;

  // --- 3. INICIAR THREAD ANÔNIMA PARA A CONSULTA NO BANCO ---
  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        // Log de Início da Consulta (Sincronizado)
        TThread.Synchronize(nil,
          procedure
          begin
            MemoEmail.Lines.Add('🔎 Executando consulta em Background: Buscando AUTORIZAÇÃO (cStat 100 OU 150)...');
          end
        );

        // --- EXECUTAR A CONSULTA NO BANCO (OFF-MAIN THREAD) ---
        // Agora com JOIN na NFE_CAB para buscar o valor total
        with DataModule1.QRYBUSCAXML do
        begin
          Close;
          SQL.Clear;

          // Montagem do SQL Completo
          SQL.Add('SELECT x.codnota, x.codemitente, x.data_emissao, x.numnota AS Num_Nota_Fiscal, x.serie AS Serie, ');
          SQL.Add('x.pedido, x.status, x.xmlchave, C.Valor_Total_Nota AS Valor, x.Tipo_Amb, x.Num_Mod_Doc ');
          SQL.Add('FROM nfe_xml x ');
          // <<< JOIN COM NFE_CAB - CHAVE DE LIGAÇÃO: CodNota e CodEmitente >>>
          SQL.Add('JOIN NFE_CAB C ON C.CodNota = x.CodNota AND C.CodEmitente = x.CodEmitente ');
          // <<< FIM DO JOIN >>>

          // Filtro por Data de Emissão (Sempre obrigatório)
          SQL.Add('WHERE x.Data_Emissao BETWEEN :DataInicio AND :DataFim ');

          // FILTRO ESSENCIAL: Autorização no XML (100 ou 150)
          SQL.Add('  AND x.Status = ''T'' ');
          SQL.Add('  AND (x.XMLTransmissao LIKE ''%<cStat>100</cStat>%'' OR x.XMLTransmissao LIKE ''%<cStat>150</cStat>%'')');

          // Filtros de Emitente e Ambiente (Sempre obrigatórios)
          SQL.Add('  AND x.CodEmitente = :CodEmitente ');
          SQL.Add('  AND x.Tipo_Amb = :Tipo_Amb ');

          // Filtro Condicional (Modelo)
          if not IsTodosOsModelos then
          begin
            SQL.Add('  AND x.Num_Mod_Doc = :Modelo ');
          end;

          // Filtro de Série Condicional
          if not IsTodasAsSeries then
            SQL.Add('  AND x.Serie = :Serie');

          SQL.Add('ORDER BY x.NumNota');

          // Passar Parâmetros
          ParamByName('CodEmitente').AsInteger := CodEmitente;
          ParamByName('DataInicio').AsDateTime := DataInicial;
          ParamByName('DataFim').AsDateTime := DataFinalComHora;
          ParamByName('Tipo_Amb').AsInteger := TipoAmbiente;

          // Passar o Parâmetro Modelo SOMENTE se o filtro foi adicionado ao SQL
          if not IsTodosOsModelos then
            ParamByName('Modelo').AsInteger := ModeloParaConsulta;

          // Passa a Série SOMENTE se a Query a usa
          if not IsTodasAsSeries then
            ParamByName('Serie').AsInteger := SerieSelecionada;

          Open;
        end;

        // --- 4. ATUALIZAR A UI E TOTAIS (SINCRONIZADO) ---
        TThread.Synchronize(nil,
          procedure
          begin
            contaregistrosemitidos;
            CalcularTotalNotasExibidas;

            MemoEmail.Lines.Add(Format('✅ Consulta concluída. Registros encontrados: %d', [DataModule1.QRYBUSCAXML.RecordCount]));
            Application.ProcessMessages;
          end
        );

      finally
        // --- 5. FECHAR FORM DE ESPERA (SINCRONIZADO) ---
        TThread.Synchronize(nil,
          procedure
          begin
            if Assigned(EsperaForm) then
            begin
              EsperaForm.Close;
              EsperaForm.Free;
            end;
          end
        );
      end;
    end
  ).Start;
end;






procedure Tfrmmenu.contaregistrosemitidos;
begin
  // Verifica se o componente de consulta está atribuído e ativo
  if Assigned(DataModule1.QRYBUSCAxml) and DataModule1.QRYBUSCAxml.Active then
  begin
    // Atualiza o LABELTOTAL com a contagem de registros da QRYBUSCAxml
    LABELTOTAL.Caption := 'Total de Registros: ' + IntToStr(DataModule1.QRYBUSCAxml.RecordCount);
  end
  else
  begin
    // Define a contagem como 0 se a query não estiver ativa ou atribuída
    LABELTOTAL.Caption := 'Total de Registros: 0';
  end;
end;

procedure Tfrmmenu.contaregistrospendente;
begin
  // Verifica se o componente de consulta está atribuído e ativo
  if Assigned(DataModule1.QRYPSQPENDENTE) and DataModule1.QRYPSQPENDENTE.Active then
  begin
    // Atualiza o LABELTOTAL com a contagem de registros da QRYBUSCAxml
    labelpendentes.Caption := 'Total de Registros: ' + IntToStr(DataModule1.QRYPSQPENDENTE.RecordCount);
  end
  else
  begin
    // Define a contagem como 0 se a query não estiver ativa ou atribuída
    LABELTOTAL.Caption := 'Total de Registros: 0';
  end;
end;


procedure Tfrmmenu.CalcularTotalNotasExibidas;
var
  TotalValor: Currency; // Use Currency para valores monetários com precisão
begin
  TotalValor := 0; // Inicializa o total

  // Verifica se a QRYBUSCAxml está ativa e tem dados
  if Assigned(DataModule1.QRYBUSCAxml) and DataModule1.QRYBUSCAxml.Active then
  begin
    // Garante que a QRYBUSCAxml esteja no primeiro registro
    DataModule1.QRYBUSCAxml.First;

    // Itera por todos os registros da QRYBUSCAxml
    while not DataModule1.QRYBUSCAxml.Eof do
    begin
      // Verifica se o campo 'ValorTotalNota' não é nulo antes de somar
      if not DataModule1.QRYBUSCAxml.FieldByName('Valor').IsNull then
      begin
        TotalValor := TotalValor + DataModule1.QRYBUSCAxml.FieldByName('Valor').AsCurrency;
      end;
      DataModule1.QRYBUSCAxml.Next; // Vai para o próximo registro
    end;
  end;

  // Exibe o total formatado como moeda na label
  labelvaloremitido.Caption := FormatCurr('R$ #,##0.00', TotalValor);
  Application.ProcessMessages; // Atualiza a label imediatamente
end;

procedure Tfrmmenu.CalcularTotalvendapendente;
var
  TotalValor: Currency; // Use Currency para valores monetários com precisão
begin
  TotalValor := 0; // Inicializa o total

  // Verifica se a QRYBUSCAxml está ativa e tem dados
  if Assigned(DataModule1.QRYPSQPENDENTE) and DataModule1.QRYPSQPENDENTE.Active then
  begin
    // Garante que a QRYBUSCAxml esteja no primeiro registro
    DataModule1.QRYPSQPENDENTE.First;

    // Itera por todos os registros da QRYBUSCAxml
    while not DataModule1.QRYPSQPENDENTE.Eof do
    begin
      // Verifica se o campo 'ValorTotalNota' não é nulo antes de somar
      if not DataModule1.QRYPSQPENDENTE.FieldByName('Valor').IsNull then
      begin
        TotalValor := TotalValor + DataModule1.QRYPSQPENDENTE.FieldByName('Valor').AsCurrency;
      end;
      DataModule1.QRYPSQPENDENTE.Next; // Vai para o próximo registro
    end;
  end;

  // Exibe o total formatado como moeda na label
  Labelvalorpendente.Caption := FormatCurr('R$ #,##0.00', TotalValor);
  Application.ProcessMessages; // Atualiza a label imediatamente
end;









procedure Tfrmmenu.SalvarXMLsInutilizadosEUtilizados;
var
  PastaTemporaria, PastaBase, RazaoSocial, CNPJ, NomeArquivoZip: String;
  ZipFile: TZipFile;
  XMLArquivo, LinhaTXT: TStringList;
  CaminhoArquivo, NomeArquivo: String;
  CodEmitente, NumNota, Modelo, Serie: Integer;
  XMLTransmissao, StatusNota: String;
  // XMLinutilizacao, GAFINU: String; // Removido daqui
  DataInicioStr, DataFimStr: String;
  XMLinutilizacao: String; // Adicionado aqui para escopo mais restrito, será resetado no loop
  GAFINU: String;
begin
  MemoEmail.Lines.Clear;
  MemoEmail.Lines.Add('Iniciando o salvamento dos XMLs da lista de notas...');
  Application.ProcessMessages;

  XMLArquivo := nil;
  LinhaTXT := nil;
  ZipFile := nil;

  try
    XMLArquivo := TStringList.Create;
    LinhaTXT := TStringList.Create;
    ZipFile := TZipFile.Create;

    if cmbempresa.ItemIndex = -1 then
    begin
      MemoEmail.Lines.Add('Erro: Nenhuma empresa (emitente) selecionada. Operação cancelada.');
      ShowMessage('Selecione uma empresa para continuar.');
      Exit;
    end;

    // Coleta os dados da tela principal
    CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
    RazaoSocial := DBTextempresa.Caption;
    CNPJ := StringReplace(DBTextcnpj.Caption, '.', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '/', '', [rfReplaceAll]);
    CNPJ := StringReplace(CNPJ, '-', '', [rfReplaceAll]);

    DataInicioStr := FormatDateTime('yyyy-mm-dd', DTinicio.Date);
    DataFimStr := FormatDateTime('yyyy-mm-dd', DTfim.Date);

    PastaBase := 'C:\XMLSERVSIC\';
    PastaTemporaria := PastaBase + 'XML_LISTA_' + FormatDateTime('yyyymmdd', Now) + '\';
    ForceDirectories(PastaTemporaria);

    MemoEmail.Lines.Add('Pastas temporárias criadas em: ' + PastaTemporaria);
    Application.ProcessMessages;

    if CDSQUEBRA.Active and not CDSQUEBRA.IsEmpty then
    begin
      CDSQUEBRA.First;
      LinhaTXT.Add('Relatório de XMLs da lista importada');
      LinhaTXT.Add('Empresa: ' + RazaoSocial + ' - CNPJ: ' + CNPJ);
      LinhaTXT.Add('Período de Referência: ' + DataInicioStr + ' a ' + DataFimStr);
      LinhaTXT.Add('');

      while not CDSQUEBRA.Eof do
      begin
        try
          // Reset das variáveis a cada iteração
          XMLTransmissao := '';
          StatusNota := '';
          XMLinutilizacao := ''; // Variável para o XML de inutilização

          // Coleta os dados de cada nota da lista (CDSQUEBRA)
          NumNota := CDSQUEBRA.FieldByName('NumNota').AsInteger;
          Modelo := CDSQUEBRA.FieldByName('Num_Mod_Doc').AsInteger;
          Serie := CDSQUEBRA.FieldByName('Serie').AsInteger;
          CodEmitente := CDSQUEBRA.FieldByName('CodEmitente').AsInteger;

          // 1. Tentar buscar na SERVXML com todos os filtros (Status 'I' - Inutilizada)
          with DataModule1.QRYINSERESERVXML do
          begin
            Close;
            SQL.Text := 'SELECT XMLtransmissao FROM SERVXML WHERE codemitente = :codemitente AND numnota = :numnota AND num_mod_doc = :num_mod_doc AND serie = :serie AND status = ''I''';
            ParamByName('codemitente').AsInteger := CodEmitente;
            ParamByName('numnota').AsInteger := NumNota;
            ParamByName('num_mod_doc').AsInteger := Modelo;
            ParamByName('serie').AsInteger := Serie;
            Open;

            if not IsEmpty then
            begin
              XMLTransmissao := FieldByName('XMLtransmissao').AsString;
              StatusNota := 'Inutilizada (SERVXML)';
            end;
            Close;
          end;

          // 2. Se não encontrou na SERVXML, tentar buscar na NFE_XML (Inutilizada, Transmitida, Cancelada)
          if XMLTransmissao = '' then
          begin
            with DataModule1.QRYINSERESERVXML do
            begin
              Close;
              // Adicionando XMLInutilizacao no SELECT
              SQL.Text := 'SELECT XMLTransmissao, XMLInutilizacao, Status FROM NFE_XML WHERE CodEmitente = :codemitente AND NumNota = :numnota AND Num_Mod_Doc = :num_mod_doc AND Serie = :serie AND Status IN (''I'', ''T'', ''C'')';
              ParamByName('codemitente').AsInteger := CodEmitente;
              ParamByName('numnota').AsInteger := NumNota;
              ParamByName('num_mod_doc').AsInteger := Modelo;
              ParamByName('serie').AsInteger := Serie;
              Open;

              if not IsEmpty then
              begin
                // Captura os dados
                XMLTransmissao := FieldByName('XMLTransmissao').AsString;
                XMLinutilizacao := FieldByName('XMLInutilizacao').AsString; // Novo campo

                // Determina o status
                if FieldByName('Status').AsString = 'I' then
                begin
                  StatusNota := 'Inutilizada (NFE_XML)';
                  // **APLICAÇÃO DA CORREÇÃO SOLICITADA:**
                  // Se o status for Inutilizada ('I') e não tiver XMLTransmissao, usa o XMLinutilizacao.
                  if (XMLTransmissao = '') and (XMLinutilizacao <> '') then
                  begin
                    XMLTransmissao := XMLinutilizacao; // Usa o XML de Inutilização
                    StatusNota := 'INUTILIZACAO_XML (NFE_XML)'; // Ajusta o status/nome para salvar
                  end;
                end
                else if FieldByName('Status').AsString = 'T' then
                  StatusNota := 'Transmitida'
                else if FieldByName('Status').AsString = 'C' then
                  StatusNota := 'Cancelada'
                else
                  StatusNota := 'Status Desconhecido (NFE_XML)';
              end
              else
                StatusNota := 'Não Encontrada';

              Close;
            end;
          end; // Fim if XMLTransmissao = ''

          // 3. Salvar o XML (se encontrado)
          if XMLTransmissao <> '' then
          begin
            // O XMLTransmissao agora pode conter o XML de Transmissão ou o XML de Inutilização
            NomeArquivo := Format('Nota_%d_Mod_%d_Serie_%d_%s.xml', [NumNota, Modelo, Serie, StringReplace(StatusNota, ' ', '_', [rfReplaceAll])]);
            CaminhoArquivo := PastaTemporaria + NomeArquivo;
            XMLArquivo.Text := XMLTransmissao;
            XMLArquivo.SaveToFile(CaminhoArquivo);
            LinhaTXT.Add(Format('XML Salvo: %s | Status: %s', [NomeArquivo, StatusNota]));
          end
          else
            LinhaTXT.Add(Format('Aviso: XML não encontrado para a nota %d. Status: %s', [NumNota, StatusNota]));

          CDSQUEBRA.Next;

        except
          on E: Exception do
          begin
            MemoEmail.Lines.Add('❌ Erro na nota ' + IntToStr(NumNota) + ': ' + E.Message);
            CDSQUEBRA.Next;
          end;
        end;
      end; // Fim while

      // ... (O restante do código é o mesmo: salvar TXT, compactar e limpar)
      LinhaTXT.SaveToFile(PastaTemporaria + 'Relatorio_Notas_Importadas.txt');
      MemoEmail.Lines.Add('Compactando os arquivos de notas...');
      Application.ProcessMessages;

      // <<<< LINHA ALTERADA AQUI >>>>
      NomeArquivoZip := PastaBase + RazaoSocial + '_' + CNPJ + '_' + 'LISTA FALTANTE''.zip';

      ZipFile.Open(NomeArquivoZip, zmWrite);
      try
        for CaminhoArquivo in TDirectory.GetFiles(PastaTemporaria, '*', TSearchOption.soTopDirectoryOnly) do
          ZipFile.Add(CaminhoArquivo, ExtractFileName(CaminhoArquivo));
      finally
        ZipFile.Close;
      end;
      MemoEmail.Lines.Add('Arquivo ZIP criado com sucesso: ' + NomeArquivoZip);
      ShowMessage('Os XMLs da lista foram salvos e compactados com sucesso em:' + #13#10 + NomeArquivoZip);
    end
    else
    begin
      MemoEmail.Lines.Add('Aviso: A lista de notas a processar está vazia. Importe um TXT antes.');
      ShowMessage('A lista de notas a processar está vazia. Importe um TXT antes.');
      Exit;
    end;
  finally
    if Assigned(XMLArquivo) then XMLArquivo.Free;
    if Assigned(LinhaTXT) then LinhaTXT.Free;
    if Assigned(ZipFile) then FreeAndNil(ZipFile);
    if DirectoryExists(PastaTemporaria) then TDirectory.Delete(PastaTemporaria, True);
    MemoEmail.Lines.Add('Processo de limpeza concluído. Pastas temporárias excluídas.');
    Application.ProcessMessages;
  end;
end;







procedure Tfrmmenu.ConsultarNotaPerdida;
var
  CodEmitente, Modelo, NumNota: Integer;
  sqlQuery: TStringList;
begin
  sqlQuery := TStringList.Create;
  try
    // ... (toda a parte de validação e conversão permanece a mesma)
    if Trim(editconsulta.Text) = '' then
    begin
      ShowMessage('Informe o número da nota fiscal.');
      editconsulta.SetFocus;
      Exit;
    end;

    try
      NumNota     := StrToInt(editconsulta.Text);
      CodEmitente := StrToIntDef(editcodemitente.Text, 0);
      Modelo      := StrToIntDef(editmodelo.Text, 0);
    except
      on E: EConvertError do
      begin
        ShowMessage('Número da nota, código do emitente e modelo devem ser valores numéricos válidos.');
        Exit;
      end;
    end;

    // Montagem da query
    sqlQuery.Add('SELECT CodNota, Data_Emissao, CodEmitente, NumNota AS num_nota_fiscal,');
    sqlQuery.Add('       Num_Mod_Doc,');
    // ***** NOVA CORREÇÃO APLICADA DIRETAMENTE NO SELECT *****
    sqlQuery.Add('       Serie COLLATE Latin1_General_CI_AS AS Num_Serie,');
    sqlQuery.Add('       Status COLLATE Latin1_General_CI_AS AS St_Retorno,');
    sqlQuery.Add('       xmlchave COLLATE Latin1_General_CI_AS AS Chave_Acesso');
    sqlQuery.Add('FROM NFE_XML');
    sqlQuery.Add('WHERE NumNota = :pNumNota1');

    if CodEmitente > 0 then
      sqlQuery.Add('AND CodEmitente = :pCodEmitente1');
    if Modelo > 0 then
      sqlQuery.Add('AND Num_Mod_Doc = :pModelo1');

    sqlQuery.Add('UNION ALL');

    sqlQuery.Add('SELECT CodNota, Data_Emissao, CodEmitente, NumNota AS num_nota_fiscal,');
    sqlQuery.Add('       Num_Mod_Doc,');
    // ***** NOVA CORREÇÃO APLICADA DIRETAMENTE NO SELECT *****
    sqlQuery.Add('       Serie COLLATE Latin1_General_CI_AS AS Num_Serie,');
    sqlQuery.Add('       Status COLLATE Latin1_General_CI_AS AS St_Retorno,');
    sqlQuery.Add('       NULL AS Chave_Acesso');
    sqlQuery.Add('FROM SERVXML');
    sqlQuery.Add('WHERE NumNota = :pNumNota2');

    if CodEmitente > 0 then
      sqlQuery.Add('AND CodEmitente = :pCodEmitente2');
    if Modelo > 0 then
      sqlQuery.Add('AND Num_Mod_Doc = :pModelo2');

    // Correção anterior (ainda necessária)
    sqlQuery.Add('AND NOT EXISTS (SELECT 1 FROM NFE_XML');
    sqlQuery.Add('                WHERE NFE_XML.NumNota = SERVXML.NumNota');
    sqlQuery.Add('                  AND NFE_XML.CodEmitente = SERVXML.CodEmitente');
    sqlQuery.Add('                  AND NFE_XML.Num_Mod_Doc = SERVXML.Num_Mod_Doc');
    sqlQuery.Add('                  AND NFE_XML.Serie COLLATE Latin1_General_CI_AS = SERVXML.Serie');
    sqlQuery.Add('                  AND NFE_XML.Status COLLATE Latin1_General_CI_AS = SERVXML.Status)');

    sqlQuery.Add('ORDER BY num_nota_fiscal, Data_Emissao DESC');

    // Executa a consulta
    try
      with DataModule1.QRYNOTAPERDIDA do
      begin
        // ... (toda a parte de execução e passagem de parâmetros permanece a mesma)
        Close;
        SQL.Clear;
        SQL.Assign(sqlQuery);

        ParamByName('pNumNota1').AsInteger := NumNota;
        ParamByName('pNumNota2').AsInteger := NumNota;

        if CodEmitente > 0 then
        begin
          ParamByName('pCodEmitente1').AsInteger := CodEmitente;
          ParamByName('pCodEmitente2').AsInteger := CodEmitente;
        end;
        if Modelo > 0 then
        begin
          ParamByName('pModelo1').AsInteger := Modelo;
          ParamByName('pModelo2').AsInteger := Modelo;
        end;

        Open;
      end;

      if DataModule1.QRYNOTAPERDIDA.IsEmpty then
        ShowMessage('Nenhum registro encontrado.')
      else
        ShowMessage('Consulta realizada com sucesso.');

    except
      on E: Exception do
        ShowMessage('Erro ao executar a consulta: ' + E.Message);
    end;

  finally
    sqlQuery.Free;
  end;
end;




procedure Tfrmmenu.ConsultarNotasPorPeriodo;
var
  DataInicio, DataFimComHora: TDateTime;
  sqlQuery: TStringList;
begin
  sqlQuery := TStringList.Create;

  // 1. COLETAR E VALIDAR AS DATAS DO FILTRO
  DataInicio := DTinicio.Date;
  // Ajusta DataFim para incluir o dia inteiro (até 23:59:59)
  DataFimComHora := DTfim.Date + (23/24) + (59/(24*60)) + (59/(24*60*60));

  if DataInicio > DataFimComHora then
  begin
    ShowMessage('❌ Data inicial não pode ser maior que a data final!');
    Exit;
  end;

  try
    // 2. MONTAGEM DA QUERY PRINCIPAL (NFE_XML)
    sqlQuery.Add('SELECT CodNota, Data_Emissao, CodEmitente, NumNota AS num_nota_fiscal,');
    sqlQuery.Add('       Num_Mod_Doc,');
    sqlQuery.Add('       Serie COLLATE Latin1_General_CI_AS AS Num_Serie,');
    sqlQuery.Add('       Status COLLATE Latin1_General_CI_AS AS St_Retorno,');
    sqlQuery.Add('       xmlchave COLLATE Latin1_General_CI_AS AS Chave_Acesso');
    sqlQuery.Add('FROM NFE_XML');
    // Filtro por Data_Emissao ou DataTransmissao (a Data_Emissao é mais comum para filtro)
    sqlQuery.Add('WHERE Data_Emissao BETWEEN :pDataInicio AND :pDataFim');

    sqlQuery.Add('UNION ALL');

    // 3. MONTAGEM DA QUERY SECUNDÁRIA (SERVXML)
    // Busca registros da SERVXML (usada para logs/inutilização) que não estão em NFE_XML
    sqlQuery.Add('SELECT CodNota, Data_Emissao, CodEmitente, NumNota AS num_nota_fiscal,');
    sqlQuery.Add('       Num_Mod_Doc,');
    sqlQuery.Add('       Serie COLLATE Latin1_General_CI_AS AS Num_Serie,');
    sqlQuery.Add('       Status COLLATE Latin1_General_CI_AS AS St_Retorno,');
    sqlQuery.Add('       NULL AS Chave_Acesso');
    sqlQuery.Add('FROM SERVXML');
    sqlQuery.Add('WHERE Data_Emissao BETWEEN :pDataInicio AND :pDataFim');

    // Cláusula para evitar duplicidade (registros que só existem em SERVXML)
    sqlQuery.Add('AND NOT EXISTS (SELECT 1 FROM NFE_XML');
    sqlQuery.Add('                WHERE NFE_XML.NumNota = SERVXML.NumNota');
    sqlQuery.Add('                  AND NFE_XML.CodEmitente = SERVXML.CodEmitente');
    sqlQuery.Add('                  AND NFE_XML.Num_Mod_Doc = SERVXML.Num_Mod_Doc');
    sqlQuery.Add('                  AND NFE_XML.Serie COLLATE Latin1_General_CI_AS = SERVXML.Serie');
    sqlQuery.Add('                  AND NFE_XML.Status COLLATE Latin1_General_CI_AS = SERVXML.Status)');

    sqlQuery.Add('ORDER BY num_nota_fiscal, Data_Emissao DESC');

    // 4. EXECUÇÃO DA CONSULTA
    try
      with DataModule1.QRYNOTAPERDIDA do
      begin
        Close;
        SQL.Clear;
        SQL.Assign(sqlQuery);

        // Passagem dos parâmetros de data (usados em ambas as partes do UNION ALL)
        ParamByName('pDataInicio').AsDateTime := DataInicio;
        ParamByName('pDataFim').AsDateTime := DataFimComHora;

        Open;
      end;

      if DataModule1.QRYNOTAPERDIDA.IsEmpty then
        ShowMessage('Nenhum registro encontrado para o período.')
      else
      //  ShowMessage(Format('Consulta realizada com sucesso. Encontrados %d registros.', [DataModule1.QRYNOTAPERDIDA.RecordCount]));

    except
      on E: Exception do
        ShowMessage('❌ Erro ao executar a consulta por período: ' + E.Message);
    end;
     ContarTotalConsultas;
  finally

    sqlQuery.Free;
  end;
end;


procedure Tfrmmenu.ContarTotalConsultas;
begin
  // A QRYNOTAPERDIDA é usada por ConsultarNotaPerdida e ConsultarNotasPorPeriodo
  if Assigned(DataModule1.QRYNOTAPERDIDA) and DataModule1.QRYNOTAPERDIDA.Active then
  begin
    // Atualiza a LABELTOTAL com a contagem de registros da QRYNOTAPERDIDA
    labeltotalconsulta.Caption := 'Total de Registros: ' + IntToStr(DataModule1.QRYNOTAPERDIDA.RecordCount);
  end
  else
  begin
    labeltotalconsulta.Caption := 'Total de Registros: 0';
  end;
end;






procedure Tfrmmenu.LimparCDSQuebra;
begin
  // Fecha o ClientDataSet para garantir que ele não esteja em modo de edição
  if CDSQUEBRA.Active then
    CDSQUEBRA.Close;

  // Limpa os dados do ClientDataSet
  // A propriedade FieldDefs.Clear garante que a estrutura de campos seja removida.
  CDSQUEBRA.FieldDefs.Clear;

  // Cria um novo conjunto de dados vazio com a estrutura inicial
  // O CDSQUEBRA é um componente em memória e precisa ser recriado para ser usado novamente
  CDSQUEBRA.FieldDefs.Add('CodNota', ftInteger);
  CDSQUEBRA.FieldDefs.Add('CodEmitente', ftInteger);
  CDSQUEBRA.FieldDefs.Add('Num_Mod_Doc', ftInteger);
  CDSQUEBRA.FieldDefs.Add('Serie', ftInteger);
  CDSQUEBRA.FieldDefs.Add('NumNota', ftInteger);
  CDSQUEBRA.FieldDefs.Add('Data_Emissao', ftDateTime);
  CDSQUEBRA.CreateDataSet;

  // Abre o ClientDataSet para uso
  CDSQUEBRA.Open;
  contaregistrosfaltantes;
end;

procedure Tfrmmenu.PularProximaNumeracaoNFCe;
var
  NumSerie, NumNotaFiscal: Integer;
  CodEmitente: Integer;
begin
  try
    // 🔹 1. Obtenção e validação dos dados
    if (Trim(cmbempresa.Text) = '') or (Trim(Editselecionaserie.Text) = '') or (Trim(Editalteraultnumusado.Text) = '') then
    begin
      ShowMessage('Por favor, selecione uma empresa e preencha a série e o número que deseja pular.');
      Exit;
    end;

    // Obter o CodEmitente da ComboBox (o Codigo está em Objects)
    CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
    NumSerie := StrToIntDef(Trim(Editselecionaserie.Text), 0);
    NumNotaFiscal := StrToIntDef(Trim(Editalteraultnumusado.Text), 0);

    // Validação adicional
    if (CodEmitente = 0) or (NumSerie = 0) or (NumNotaFiscal = 0) then
    begin
      ShowMessage('Valores de entrada inválidos. Certifique-se de que a empresa, série e número são válidos.');
      Exit;
    end;

    // 🔹 2. Preparação da Query SQL
    // A query é a mesma da sua unit ALTERARCX, mas vamos simplificá-la um pouco
    // para usar diretamente o valor fornecido pelo usuário.
    // Usaremos a query QRYNOVONUMNFCEMANUAL que você já tem no DataModule.
    DataModule1.QRYNOVONUMNFCEMANUAL.Close;
    DataModule1.QRYNOVONUMNFCEMANUAL.SQL.Text :=
      'DECLARE @NovoCodNota INT; ' +
      'SELECT @NovoCodNota = ISNULL(MAX(CodNota), 0) + 1 FROM NFe_Cab; ' +
      'INSERT INTO NFe_Cab (CodNota, Num_Nota_Fiscal, Tipo_Ambiente, Num_Serie, Ind_Emit, CodEmitente, Num_Mod_Doc, Data_Emissao) ' +
      'VALUES (@NovoCodNota, :NumNotaFiscal, 1, :NumSerie, 0, :CodEmitente, 65, GETDATE());';

    // 🔹 3. Definição dos parâmetros
    DataModule1.QRYNOVONUMNFCEMANUAL.ParamByName('NumNotaFiscal').AsInteger := NumNotaFiscal;
    DataModule1.QRYNOVONUMNFCEMANUAL.ParamByName('NumSerie').AsInteger := NumSerie;
    DataModule1.QRYNOVONUMNFCEMANUAL.ParamByName('CodEmitente').AsInteger := CodEmitente;

    // 🔹 4. Execução da Query
    DataModule1.QRYNOVONUMNFCEMANUAL.ExecSQL;

    ShowMessage(Format('O número %d da série %d foi registrado como pulado. A próxima NFC-e usará a numeração seguinte.', [NumNotaFiscal, NumSerie]));

  except
    on E: Exception do
      ShowMessage('Erro ao tentar pular a numeração: ' + E.Message);
  end;
end;









procedure Tfrmmenu.ConsultarVendasPendentes;
var
  CodEmitente: Integer;
  DataInicial, DataFinalComHora: TDateTime; // <-- Variáveis de data adicionadas
begin
  // 1. Validar seleção de emitente
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('?? Por favor, selecione uma empresa (emitente) antes de buscar as vendas pendentes.');
    Exit;
  end;

  // 2. Obter os filtros (Emitente e Período)
  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);
  DataInicial := DTinicio.Date;
  // Garante que a data final inclua até o último segundo do dia
  DataFinalComHora := DTfim.Date + (23/24) + (59/(24*60)) + (59/(24*60*60));

  try
    logpendentes.Lines.Add('?? Buscando vendas pendentes com Status ''G''...');
    logpendentes.Lines.Add(Format('Período: %s a %s', [FormatDateTime('dd/mm/yyyy', DataInicial), FormatDateTime('dd/mm/yyyy', DTfim.Date)]));
    Application.ProcessMessages;

    // 3. Executar a Query no DataModule
    with DataModule1.QRYPSQPENDENTE do // Usando QRYPSQPENDENTE
    begin
      Close;
      SQL.Clear;

      // SQL com o filtro de data (usando datageracao)
      SQL.Text := 'SELECT codemitente, CodNota, NumNota, Serie,Num_mod_doc, datageracao,XMLchave, Valor, Status, Pedido,Rejeicaomotivo,xmlgeracao FROM NFE_XML ' +
                  'WHERE CodEmitente = :CodEmitente ' +
                  // NOVO FILTRO DE DATA
                  '  AND datageracao BETWEEN :DataInicial AND :DataFinalComHora ' +
                  '  AND Status = ''G'' ' +
                  'ORDER BY datageracao DESC;';

      // 4. Definição dos parâmetros
      ParamByName('CodEmitente').AsInteger := CodEmitente;
      // NOVOS PARÂMETROS DE DATA
      ParamByName('DataInicial').AsDateTime := DataInicial;
      ParamByName('DataFinalComHora').AsDateTime := DataFinalComHora;

      Open;
    end;

    // 5. Ligar os resultados ao DBGridPendentes
    DataModule1.DSQRYPSQPENDENTE.DataSet := DataModule1.QRYPSQPENDENTE; // Usando DSQRYPSQPENDENTE
    DBGridPendentes.DataSource := DataModule1.DSQRYPSQPENDENTE; // Ligando ao DBGrid

    logpendentes.Lines.Add(Format('? Consulta concluída. Encontrado %d registros pendentes.', [DataModule1.QRYPSQPENDENTE.RecordCount]));
    Application.ProcessMessages;

  except
    on E: Exception do
    begin
      ShowMessage('? Erro ao consultar vendas pendentes: ' + E.Message);
      logpendentes.Lines.Add('? Erro ao consultar vendas pendentes: ' + E.Message);
    end;
  end;

  CalcularTotalvendapendente;
  contaregistrospendente;
end;










procedure Tfrmmenu.AtualizarStatusEProtocolo(const ACodNota: Integer; const AXMLChave: string;
  const ACStat: Integer; const AXMotivo: string; const AXMLProtocolo: string);
var
  StatusNovo: string;
  StatusDescricao: string;
begin
  // 1. Determina o status interno (T)
  if (ACStat = 100) or (ACStat = 150) then // 100: Autorizada, 150: Uso Denegado
  begin
    StatusNovo := 'T';
    StatusDescricao := 'Autorizada/Denegada';
  end
  else // Rejeição (2xx, 3xx), Erros (4xx, 5xx) ou Outros
  begin
    // Mantém o status 'G' (Gerada/Pendente) se for rejeição, para re-tentativa ou auditoria.
    StatusNovo := 'G';
    StatusDescricao := 'Rejeitada';
  end;

  try
    DataModule1.ConDados.StartTransaction;

    with DataModule1.QRYupdatebanco do
    begin
      Close;
      SQL.Clear;

      // SQL para atualizar o registro na NFE_XML
      // A atualização se limita ao Status, Retorno SEFAZ e XML de Transmissão/Protocolo.
      SQL.Add('UPDATE NFE_XML SET');
      SQL.Add('  Status = :pStatus,');
      SQL.Add('  ST_Retorno = :pCStat,');
      SQL.Add('  RejeicaoMotivo = :pMotivo,');
      // **A última linha DEVE ser o XMLTransmissao para não ter vírgula antes do WHERE**
      SQL.Add('  XMLTransmissao = :pXML');

      // Condição de segurança
      SQL.Add('WHERE CodNota = :pCodNota AND XMLChave = :pChave');

      // Parametrização
      ParamByName('pStatus').AsString := StatusNovo;
      ParamByName('pCStat').AsInteger := ACStat;
      ParamByName('pMotivo').AsString := AXMotivo;
      ParamByName('pXML').AsString := AXMLProtocolo;
      ParamByName('pCodNota').AsInteger := ACodNota;
      ParamByName('pChave').AsString := AXMLChave;

      ExecSQL;
    end;

    DataModule1.ConDados.Commit;
    logpendentes.Lines.Add(Format('✅ Nota %s atualizada. Status: %s - %d: %s',
      [Copy(AXMLChave, 35, 10), StatusNovo, ACStat, AXMotivo]));

  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add(Format('❌ Erro ao salvar status da nota %s: %s',
        [Copy(AXMLChave, 35, 10), E.Message]));
    end;
  end;
end;



function Tfrmmenu.BuscarXMLGeracao(const ACodNota: Integer): string;
begin
  Result := '';
  try
    with DataModule1.QRYBUSCAXML do // Reutilizando QRYBUSCAXML ou crie uma nova.
    begin
      Close;
      SQL.Clear;
      SQL.Add('SELECT XMLGeracao FROM NFE_XML WHERE CodNota = :pCodNota');
      ParamByName('pCodNota').AsInteger := ACodNota;
      Open;
      if not IsEmpty then
      begin
        // Retorna o conteúdo do campo XMLGeracao (que é um BLOB/Memo no SQL Server)
        Result := FieldByName('XMLGeracao').AsString;
      end;
      Close;
    end;
  except
    on E: Exception do
      logpendentes.Lines.Add('❌ Erro ao buscar XMLGeracao: ' + E.Message);
  end;
end;


procedure Tfrmmenu.Button1Click(Sender: TObject);
begin
AtualizarChavesCorretas;
end;

function Tfrmmenu.MesclarXMLComProtocolo(const AXMLOriginal: string; const AXMLProtocoloSOAP: string): string;
var
  XMLNFe_SemCabecalho: string;
  XMLNFe_Envolvida: string; // Nova variável para o bloco <NFe>...</NFe>
  ProtocoloXML: string;
  PosInicio, PosFim: Integer;
begin
  // 1. Remoção do cabeçalho XML (<?xml...?>) - (Fluxo existente)
  XMLNFe_SemCabecalho := Trim(AXMLOriginal);
  if StartsText('<?xml', XMLNFe_SemCabecalho) then
  begin
    PosFim := Pos('?>', XMLNFe_SemCabecalho);
    if PosFim > 0 then
      XMLNFe_SemCabecalho := Copy(XMLNFe_SemCabecalho, PosFim + 2, Length(XMLNFe_SemCabecalho));
  end;

  // 2. CORREÇÃO PRINCIPAL: Assegura que o conteúdo de <NFe> esteja completo e limpo
  //    O XMLGeracao (AXMLOriginal) deve ser o XML da NF-e Assinada (<NFe>...</NFe>)

  // 2.1. Extrai o conteúdo EXATO do <NFe>... (incluindo o Signature)
  PosInicio := Pos('<NFe', AXMLOriginal);
  PosFim := Pos('</NFe>', AXMLOriginal);

  if (PosInicio > 0) and (PosFim > 0) then
  begin
    // Captura o bloco <NFe ...> até </NFe>
    XMLNFe_Envolvida := Copy(AXMLOriginal, PosInicio, PosFim + Length('</NFe>') - PosInicio);
  end
  else
  begin
    // Se a tag <NFe> não foi encontrada (talvez o XMLGeracao só tenha <infNFe>),
    // precisamos reverter e ENVOLVER o bloco:
    PosInicio := Pos('<infNFe', AXMLOriginal);
    PosFim := Pos('</Signature>', AXMLOriginal);

    if (PosInicio > 0) and (PosFim > 0) then
    begin
        // Se encontramos <infNFe> e </Signature>, envolvemos o bloco com <NFe>
        XMLNFe_SemCabecalho := Copy(AXMLOriginal, PosInicio, PosFim + Length('</Signature>') - PosInicio);
        XMLNFe_Envolvida := Format('<NFe versao="4.00">%s</NFe>', [XMLNFe_SemCabecalho]); // <--- ENVOLVENDO AQUI!
    end
    else
    begin
        // Se falhar a extração, retorna o original (provavelmente rejeitado e não assinado)
        Result := AXMLOriginal;
        Exit;
    end;
  end;

  // 3. Extração do <protNFe> do Retorno SOAP (AXMLProtocoloSOAP)
  PosInicio := Pos('<protNFe', AXMLProtocoloSOAP);
  PosFim := Pos('</protNFe>', AXMLProtocoloSOAP);

  if (PosInicio > 0) and (PosFim > 0) then
  begin
    ProtocoloXML := Copy(AXMLProtocoloSOAP, PosInicio, (PosFim + Length('</protNFe>')) - PosInicio);

    // 4. Montagem final do <nfeProc> (Juntando NFe e protNFe)
    Result := '<?xml version="1.0" encoding="UTF-8"?>' + #13#10 +
              Format('<nfeProc versao="4.00" xmlns="http://www.portalfiscal.inf.br/nfe">%s%s</nfeProc>', [
                XMLNFe_Envolvida, // O bloco COMPLETO <NFe>...</NFe>
                ProtocoloXML
              ]);
  end
  else
    Result := AXMLOriginal; // Retorna o original se o protocolo não for encontrado
end;








procedure Tfrmmenu.AuditarNotaSEFAZ;
var
  EsperaForm: TfrmEspera;
  NumNota, Serie, Modelo: Integer;
  Ano: Integer;
  CNPJ: string;
  CodEmitenteEmit: Integer;
  XMLProcInutNFe: string;
  CodNotaLocal: Integer;
  cStatRetorno: Integer;
  xMotivo: string;
  XMLArquivo: TStringList;
  // Variável para determinar se a nota deve ser salva/movida (102 ou 563)
  bNotaResolvida: Boolean;
  TotalRegistros: Integer; // Adicionado: Total de registros para o contador
begin
  // 1. Limpeza e Log Inicial
  logpendentes.Lines.Clear;
  logpendentes.Lines.Add('>>> INICIANDO AUDITORIA DE INUTILIZAÇÃO NA SEFAZ <<<');
  Application.ProcessMessages;

  // 2. Coleta de Dados Essenciais e Validação
  if frmACBrNFe.edtNumSerie.Text = '' then Exit;
  frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := frmACBrNFe.edtNumSerie.Text;
  if DataModule1.QRYEMITENTE.IsEmpty then Exit;

  CNPJ := DataModule1.QRYEMITENTE.FieldByName('CNPJ').AsString;
  CodEmitenteEmit := DataModule1.QRYEMITENTE.FieldByName('Codigo').AsInteger;
  Ano := YearOf(Date);

  // 3. Obtém o total de registros (para exibir no Form de Espera)
  TotalRegistros := 0;
  if DataModule1.QRYPSQPENDENTE.Active then
      TotalRegistros := DataModule1.QRYPSQPENDENTE.RecordCount;

  // 4. Cria e Exibe o Form de Espera
  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Label1.Caption := Format('Iniciando auditoria de %d notas...', [TotalRegistros]);
    EsperaForm.Show;
    Application.ProcessMessages;

    DataModule1.QRYPSQPENDENTE.DisableControls;
    DataModule1.QRYPSQPENDENTE.First;

    while not DataModule1.QRYPSQPENDENTE.Eof do
    begin
      // Adiciona separador visual
      logpendentes.Lines.Add('----------------------------------------------------');
      XMLProcInutNFe := '';

      try
          // 5. Coleta dos dados do registro atual
          CodNotaLocal := DataModule1.QRYPSQPENDENTE.FieldByName('CodNota').AsInteger;
          NumNota := DataModule1.QRYPSQPENDENTE.FieldByName('NumNota').AsInteger;
          Serie := DataModule1.QRYPSQPENDENTE.FieldByName('Serie').AsInteger;
          Modelo := DataModule1.QRYPSQPENDENTE.FieldByName('Num_Mod_Doc').AsInteger;

          // Atualiza o Form de Espera para o item atual
          EsperaForm.Label1.Caption := Format('Auditando Nota %d... (%d de %d)',
            [NumNota, DataModule1.QRYPSQPENDENTE.RecNo, TotalRegistros]);
          Application.ProcessMessages;

          if DataModule1.QRYPSQPENDENTE.FieldByName('Status').AsString <> 'G' then
          begin
            logpendentes.Lines.Add(Format('⚠️ NOTA %d: Ignorada. Status não é ''G'' (Gerada/Pendente).', [NumNota]));
            DataModule1.QRYPSQPENDENTE.Next;
            Application.ProcessMessages;
            Continue;
          end;

          logpendentes.Lines.Add(Format('🔎 Auditando: Nota %d / Série %d / Modelo %d...', [NumNota, Serie, Modelo]));

          // 6. CHAMA O WEB SERVICE DE INUTILIZAÇÃO (CONSULTA NA SEFAZ)
          try
            // O ACBr usa Inutiliza(Ano, Modelo,...) para consultar no Web Service
            frmACBrNFe.ACBrNFe1.WebServices.Inutiliza(CNPJ, 'Auditoria de Inutilizacao', Ano, Modelo, Serie, NumNota, NumNota);
          except
            on E: Exception do
              logpendentes.Lines.Add(Format('❌ Erro de Comunicação: %s', [E.Message])); // [cite: 725]
          end;

          // 7. CAPTURA DOS DADOS PÓS-OPERAÇÃO
          cStatRetorno := frmACBrNFe.ACBrNFe1.WebServices.Inutilizacao.cStat; // [cite: 726]
          xMotivo := frmACBrNFe.ACBrNFe1.WebServices.Inutilizacao.xMotivo; // [cite: 727]
          XMLProcInutNFe := frmACBrNFe.ACBrNFe1.WebServices.Inutilizacao.XML_ProcInutNFe; // [cite: 727]

          // 8. REGRA DE NEGÓCIO: SALVAR/MOVER SE FOR 102 (Inutilização OK) OU 563 (Inutilização já enviada)
          bNotaResolvida := (cStatRetorno = 102) OR (cStatRetorno = 563); // [cite: 727]

          if bNotaResolvida then
          begin
            logpendentes.Lines.Add(Format('✅ Nota Inutilizada (cStat %d). %s', [cStatRetorno, xMotivo]));
            logpendentes.Lines.Add('Salvando registro e removendo da pendência...');

            // A) SALVA O LOG EM SERVXML (PRIORIDADE)
            SalvarLogServxml(CodNotaLocal, NumNota, Serie, Modelo, CodEmitenteEmit, XMLProcInutNFe, cStatRetorno); // [cite: 729]

            // B) DELETA A PENDÊNCIA DA NFE_XML (SEGUNDA AÇÃO)
           mudanotaparanegativo(CodNotaLocal, NumNota);
          end
          else
          begin
            logpendentes.Lines.Add(Format('❌ RESULTADO: STATUS %d. Motivo: %s', [cStatRetorno, xMotivo]));
          end;

        except // Captura erros no ciclo de processamento
          on E: Exception do
          begin
            logpendentes.Lines.Add(Format('❌ ERRO CRÍTICO NO CICLO DE PROCESSAMENTO DA NOTA %d: %s', [NumNota, E.Message]));
          end;
        end;

      DataModule1.QRYPSQPENDENTE.Next;
      Application.ProcessMessages;
    end; // Fim do while

    // 9. Finalização
    DataModule1.QRYPSQPENDENTE.EnableControls;
    logpendentes.Lines.Add('----------------------------------------------------');
    logpendentes.Lines.Add('✅ AUDITORIA CONCLUÍDA.');
    ConsultarVendasPendentes;

  finally
    // 10. Libera o Form de Espera
    if Assigned(EsperaForm) then FreeAndNil(EsperaForm);
  end;
end;




procedure Tfrmmenu.BitBtn1Click(Sender: TObject);
begin
frmACBrNFe.recuperaxml;
end;


procedure Tfrmmenu.mudanotaparanegativo(const ACodNota: Integer; const ANumNota: Integer);
begin
  // Esta operação DEVE ser isolada em sua própria transação
  try
    DataModule1.ConDados.StartTransaction;

    with DataModule1.QRYUPDATEBANCO do // Reutilizamos a query de UPDATE
    begin
      Close;
      // 💡 Ação: Altera o CodNota para o valor negativo e muda o Status
      SQL.Text := 'UPDATE NFE_XML SET CodNota = CodNota * -1, Status = ''I'', RejeicaoMotivo = :pMotivo ' +
                  'WHERE CodNota = :pCodNota AND NumNota = :pNumNota;';

      ParamByName('pCodNota').AsInteger := ACodNota;
      ParamByName('pNumNota').AsInteger := ANumNota;
      ParamByName('pMotivo').AsString := 'Inutilizada (Histórico)'; // Adiciona um motivo claro para o Status 'I'

      ExecSQL;
      logpendentes.Lines.Add(Format('🔄 REGISTRO MOVIDO para Histórico. Novo CodNota: -%d.', [ACodNota]));
    end;

    DataModule1.ConDados.Commit;
  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add(Format('⚠️ ERRO na movimentação de histórico da Nota %d: %s', [ANumNota, E.Message]));
    end;
  end;
end;


procedure Tfrmmenu.SalvarLogServxml(const ACodNota, ANumNota, ASerie, AModelo, ACodEmitente: Integer;
  const AXMLProcInutNFe: string; const ACStat: Integer);
var
  bServxmlExiste: Boolean;
begin
  // A transação aqui garante que a checagem de existência e o INSERT sejam atômicos.
  try
    DataModule1.ConDados.StartTransaction;

    // A) Checagem de Duplicação (Garantindo que o log não seja inserido duas vezes)
    bServxmlExiste := False;
    with DataModule1.QRYVERIFICASERVXML do
    begin
      Close;
      SQL.Text := 'SELECT TOP 1 1 FROM SERVXML WHERE numnota = :pNumNota AND serie = :pSerie AND codemitente = :pCodEmitente;';

      ParamByName('pNumNota').AsInteger := ANumNota;
      ParamByName('pSerie').AsInteger := ASerie;
      ParamByName('pCodEmitente').AsInteger := ACodEmitente;
      Open;

      bServxmlExiste := not IsEmpty;
      Close;
    end;

    // B) INSERT na tabela SERVXML (Registro de Log)
    if not bServxmlExiste then
    begin
      with DataModule1.QRYINSERESERVXML do
      begin
        Close;
        SQL.Text := 'INSERT INTO SERVXML (codnota, codemitente, numnota, num_mod_doc, serie, XMLtransmissao, data_emissao, status) ' +
                    'VALUES (:codnota, :codemitente, :numnota, :num_mod_doc, :serie, :XMLtransmissao, :data_emissao, :status)';

        ParamByName('codnota').AsInteger := ACodNota;
        ParamByName('codemitente').AsInteger := ACodEmitente;
        ParamByName('numnota').AsInteger := ANumNota;
        ParamByName('num_mod_doc').AsInteger := AModelo;
        ParamByName('serie').AsInteger := ASerie;
        ParamByName('XMLtransmissao').AsString := AXMLProcInutNFe;
        ParamByName('data_emissao').AsDateTime := Date;
        ParamByName('status').AsString := 'I'; // Inutilizado

        ExecSQL;
        logpendentes.Lines.Add(Format('✅ REGISTRO SALVO! (cStat %d).', [ACStat]));
      end;
    end
    else
    begin
      logpendentes.Lines.Add(Format('⚠️ REGISTRO JÁ EXISTE NO BANCO para Nota %d.', [ANumNota]));
    end;

    DataModule1.ConDados.Commit;
  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add(Format('❌ ERRO CRÍTICO na TRANSAÇÃO SERVXML da Nota %d: %s', [ANumNota, E.Message]));
    end;
  end;
end;











procedure Tfrmmenu.AtualizarStatusEProtocoloParaReenvio(const ACodNota: Integer; const AXMLChave: string;
  const ACStat: Integer; const AXMotivo: string; const AXMLProtocolo: string);
var
  StatusNovo: string;
  StatusDescricao: string;
begin
  // 1. Determina o status interno (T ou G)
  if (ACStat = 100) or (ACStat = 150) then // 100: Autorizada, 150: Uso Denegado
  begin
    StatusNovo := 'T';
    StatusDescricao := 'Autorizada';
  end
  else // Rejeição (2xx, 3xx), Erros (4xx, 5xx) ou Outros
  begin
    StatusNovo := 'G';
    StatusDescricao := 'Rejeitada';
  end;

  try
    DataModule1.ConDados.StartTransaction;

    with DataModule1.QRYupdatebanco do
    begin
      Close;
      SQL.Clear;

      // SQL para atualizar o registro na NFE_XML
      SQL.Add('UPDATE NFE_XML SET');
      SQL.Add('  Status = :pStatus,');
      SQL.Add('  ST_Retorno = :pCStat,');
      SQL.Add('  RejeicaoMotivo = :pMotivo');

      // 2. ATUALIZA AS DATAS BASEADO NO STATUS (Corpo da Lógica)
      if StatusNovo = 'T' then
      begin
        // Se Autorizada/Denegada (T): Atualiza a data de emissão/transmissão
        SQL.Add(', DataTransmissao = GETDATE()');
        SQL.Add(', Data_emissao = GETDATE()');
        SQL.Add(', Data_Rejeicao = NULL'); // Garante que a data de rejeição seja nula
      end
      else
      begin
        // Se Rejeitada (G): Atualiza a data de Rejeição
        SQL.Add(', Data_Rejeicao = GETDATE()');
        SQL.Add(', DataTransmissao = NULL'); // Garante que a data de transmissão seja nula
      end;

      // 3. CAMPO CRÍTICO: XMLTransmissao DEVE VIR POR ÚLTIMO (antes do WHERE)
      // Esta coluna receberá o XML COMPLETO (<nfeProc>) ou o SOAP de Rejeição.
      SQL.Add(', XMLTransmissao = :pXML');

      // 4. Condição de segurança
      SQL.Add('WHERE CodNota = :pCodNota AND XMLChave = :pChave');

      // 5. Parametrização
      ParamByName('pStatus').AsString := StatusNovo;
      ParamByName('pCStat').AsInteger := ACStat;
      ParamByName('pMotivo').AsString := AXMotivo;
      ParamByName('pXML').AsString := AXMLProtocolo; // <--- Salva o XML Completo/SOAP aqui
      ParamByName('pCodNota').AsInteger := ACodNota;
      ParamByName('pChave').AsString := AXMLChave;

      ExecSQL;
    end;

    DataModule1.ConDados.Commit;
    logpendentes.Lines.Add(Format('✅ NOTA REENVIADA/ATUALIZADA. Status: %s - %d: %s',
      [StatusNovo, ACStat, AXMotivo]));

  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add(Format('❌ Erro ao salvar status da nota %s: %s',
        [Copy(AXMLChave, 35, 10), E.Message]));
    end;
  end;
end;




procedure Tfrmmenu.InutilizarNotasFaltantes;
var
  Modelo, Serie, Ano, NumeroInicial, NumeroFinal, Justificativa, CNPJ: String;
  XMLProcInutNFe: String;
  DataEmissao: TDateTime;
  NotaJaInutilizada: Boolean;
  cStatRetorno: Integer;
begin
  memoemail.Lines.Clear;
  memoemail.Lines.Add('Iniciando o processo de inutilização de notas fiscais...');
  Application.ProcessMessages;

  if CDSQUEBRA.IsEmpty then Exit;

  // ***************************************************************
  // 1. CONFIGURAÇÃO EXPLÍCITA DO CERTIFICADO (PRIORIDADE: NumSerie)
  // ***************************************************************
  if frmACBrNFe.edtNumSerie.Text <> '' then
  begin
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := frmACBrNFe.edtNumSerie.Text;
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := '';
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.Senha := '';
  end
  else if frmACBrNFe.edtCaminho.Text <> '' then
  begin
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := '';
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.ArquivoPFX := frmACBrNFe.edtCaminho.Text;
    frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.Senha := frmACBrNFe.edtSenha.Text;
  end
  else
  begin
    logpendentes.Lines.Add('❌ Falha na configuração: Nenhum certificado digital encontrado. Operação cancelada.');
    Exit;
  end;
  // ***************************************************************

  // Variáveis fixas
  Justificativa := 'Quebra na sequencia de notas devido erros de internet';
  CNPJ := DataModule1.QRYEMITENTE.FieldByName('CNPJ').AsString;

  memoemail.Lines.Add('🔄 Iniciando envio de Inutilização nota a nota...');

  CDSQUEBRA.First;
  while not CDSQUEBRA.Eof do
  begin
    XMLProcInutNFe := '';

    try
      // 2. CAPTURA DOS DADOS DA NOTA ATUAL
      DataEmissao := CDSQUEBRA.FieldByName('Data_Emissao').AsDateTime;
      Ano := FormatDateTime('yyyy', Date);
      Modelo := IntToStr(CDSQUEBRA.FieldByName('Num_Mod_Doc').AsInteger);
      Serie := IntToStr(CDSQUEBRA.FieldByName('Serie').AsInteger);
      NumeroInicial := IntToStr(CDSQUEBRA.FieldByName('NumNota').AsInteger);

      // *******************************************************************
      // 3. VERIFICAÇÃO DE SEGURANÇA: CStat 102 JÁ EXISTENTE (PROTEÇÃO DE INTEGRIDADE)
      // *******************************************************************
//      NotaJaInutilizada := False;
//
//      with DataModule1.QRYVERIFICAINUTILIZACAO do
//      begin
//        Close;
//        SQL.Text := 'SELECT XMLtransmissao FROM SERVXML ' +
//                    'WHERE numnota = :pNumNota AND serie = :pSerie ' +
//                    'AND codemitente = :pCodEmitente AND status = ''I'' ' +
//                    'AND XMLtransmissao LIKE ''%<cStat>102</cStat>%''';
//
//        ParamByName('pNumNota').AsInteger := StrToInt(NumeroInicial);
//        ParamByName('pSerie').AsInteger := StrToInt(Serie);
//        ParamByName('pCodEmitente').AsInteger := DataModule1.QRYEMITENTE.FieldByName('Codigo').AsInteger;
//        Open;
//
//        if not IsEmpty then
//          NotaJaInutilizada := True;
//        Close;
//      end;
//
//      if NotaJaInutilizada then
//      begin
//        logpendentes.Lines.Add(Format('🔒 Nota %s Série %s: Já Esta Inutilizazada no Banco de Dados.', [NumeroInicial, Serie]));
//        CDSQUEBRA.Next;
//        Continue; // Pula para a próxima nota, protegendo o registro existente.
//      end;
//      // *******************************************************************

      // 4. ENVIO PARA A SEFAZ
      memoemail.Lines.Add(Format('📤 Enviando pedido de inutilização da nota %s Série %s...', [NumeroInicial, Serie]));

      try
        frmACBrNFe.ACBrNFe1.WebServices.Inutiliza(CNPJ, Justificativa, StrToInt(Ano), StrToInt(Modelo),
          StrToInt(Serie), StrToInt(NumeroInicial), StrToInt(NumeroInicial));

       memoemail.Lines.Add(Format('✅ Nota %s INUTILIZADA COM SUCESSO!.', [NumeroInicial]));

      except
        on E: Exception do
        begin
          memoemail.Lines.Add(Format('❌ Rejeição: %s.', [E.Message]));
        end;
      end;

      // 5. CAPTURA O XML FINAL E DADOS PÓS-OPERAÇÃO
      cStatRetorno := frmACBrNFe.ACBrNFe1.WebServices.Inutilizacao.cStat;
      XMLProcInutNFe := frmACBrNFe.ACBrNFe1.WebServices.Inutilizacao.XML_ProcInutNFe;

      // 6. SALVANDO NO BANCO DE DADOS (SERVXML)
      if Length(Trim(XMLProcInutNFe)) > 50 then
      begin

        // ***************************************************************
        // LÓGICA DE PREVENÇÃO DE DUPLICAÇÃO E ATUALIZAÇÃO
        // ***************************************************************
        with DataModule1.QRYINSERESERVXML do // Reutilizamos essa Query para a lógica de UPDATE/INSERT
        begin
            // 6.1. CHECK se um registro *não-102* já existe (para atualização)
            Close;
            SQL.Text := 'SELECT CodNota FROM SERVXML WHERE numnota = :pNumNota AND serie = :pSerie AND codemitente = :pCodEmitente;';
            ParamByName('pNumNota').AsInteger := StrToInt(NumeroInicial);
            ParamByName('pSerie').AsInteger := StrToInt(Serie);
            ParamByName('pCodEmitente').AsInteger := DataModule1.QRYEMITENTE.FieldByName('Codigo').AsInteger;
            Open;

            if not IsEmpty then
            begin
                // 6.2. SE EXISTE: FAZ UPDATE (Substitui o log antigo)
                Close;
                SQL.Text := 'UPDATE SERVXML SET XMLtransmissao = :pXML, data_emissao = :pDate ' +
                            'WHERE numnota = :pNumNota AND serie = :pSerie AND codemitente = :pCodEmitente;';

                ParamByName('pXML').AsString := XMLProcInutNFe;
                ParamByName('pDate').AsDateTime := Date;
                ExecSQL;
                memoemail.Lines.Add(Format('🔄 REGISTRO ATUALIZADO para Nota %s.', [NumeroInicial]));
            end
            else
            begin
                // 6.3. SE NÃO EXISTE: FAZ INSERT (Novo log)
                Close;
                SQL.Text := 'INSERT INTO SERVXML (codnota, codemitente, numnota, num_mod_doc, serie, XMLtransmissao, data_emissao, status) ' +
                            'VALUES (:codnota, :codemitente, :numnota, :num_mod_doc, :serie, :XMLtransmissao, :data_emissao, :status)';

                ParamByName('codnota').AsInteger := CDSQUEBRA.FieldByName('CodNota').AsInteger;
                ParamByName('codemitente').AsInteger := DataModule1.QRYEMITENTE.FieldByName('Codigo').AsInteger;
                ParamByName('numnota').AsInteger := StrToInt(NumeroInicial);
                ParamByName('num_mod_doc').AsInteger := StrToInt(Modelo);
                ParamByName('serie').AsInteger := StrToInt(Serie);
                ParamByName('XMLtransmissao').AsString := XMLProcInutNFe;
                ParamByName('data_emissao').AsDateTime := Date;
                ParamByName('status').AsString := 'I';

                ExecSQL;
                memoemail.Lines.Add(Format('✅ NOVO REGISTRO ADCIONADO no BD para Nota %s.', [NumeroInicial]));
            end;
        end;
        // ***************************************************************
      end
      else
      begin
        memoemail.Lines.Add(Format('⚠️ XML FINAL VAZIO para Nota %s. Nenhum XML salvo no BD (Falha de comunicação/ACBr).', [NumeroInicial]));
      end;


    except // Captura erros GLOBAIS
      on E: Exception do
        memoemail.Lines.Add(Format('❌ ERRO CRÍTICO GLOBAL (Nota %s): %s', [NumeroInicial, E.Message]));
    end;

    CDSQUEBRA.Next;
  end; // Fim do while

  memoemail.Lines.Add('✅ Processo de inutilização concluído!');
end;



procedure Tfrmmenu.ConsultarPorChaveDireta;
var
  ChaveAcesso: String;
begin
  // Limpa o memo de logs e coleta a chave
  MemoConsulta.Lines.Clear;
  ChaveAcesso := Trim(Editchave.Text);

  // 1. VALIDAÇÃO
  if Length(ChaveAcesso) <> 44 then
  begin
    ShowMessage('Por favor, digite a Chave de Acesso completa (44 dígitos).');
    MemoConsulta.Lines.Add('❌ Erro: Chave de Acesso inválida.');
    Exit;
  end;

  // 2. CONFIGURAÇÃO E CONECTIVIDADE

  // Verifica o Certificado (necessário para a consulta na SEFAZ)
  if frmACBrNFe.edtNumSerie.Text = '' then
  begin
    MemoConsulta.Lines.Add('❌ Erro: O Número de Série do Certificado não está configurado.');
    Exit;
  end;
  frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := frmACBrNFe.edtNumSerie.Text;

  MemoConsulta.Lines.Add('🔎 1. Consultando Chave ' + ChaveAcesso + ' diretamente na SEFAZ...');
  Application.ProcessMessages;

  // 3. CONSULTA NA SEFAZ VIA ACBR
  try
    // Configura a chave e executa a consulta de situação
    frmACBrNFe.ACBrNFe1.WebServices.Consulta.NFeChave := ChaveAcesso;
    frmACBrNFe.ACBrNFe1.WebServices.Consulta.Executar;

    // 4. EXIBE RESULTADOS
    MemoConsulta.Lines.Add('----------------------------------------');
    MemoConsulta.Lines.Add('✅ 2. CONSULTA FINALIZADA');
    MemoConsulta.Lines.Add('Status (cStat): ' + IntToStr(frmACBrNFe.ACBrNFe1.WebServices.Consulta.cStat));
    MemoConsulta.Lines.Add('Motivo (xMotivo): ' + frmACBrNFe.ACBrNFe1.WebServices.Consulta.xMotivo);
    MemoConsulta.Lines.Add('Protocolo: ' + frmACBrNFe.ACBrNFe1.WebServices.Consulta.Protocolo);
    MemoConsulta.Lines.Add('----------------------------------------');
    MemoConsulta.Lines.Add(frmACBrNFe.ACBrNFe1.WebServices.Consulta.RetornoWS);

  except
    on E: Exception do
      MemoConsulta.Lines.Add('❌ ERRO na comunicação com SEFAZ: ' + E.Message);
  end;
end;

procedure Tfrmmenu.ImportarListaChaves;
var
  ArquivoTXT: TStringList;
  LinhaNota: string;
  LinhaTrabalhada: string;
  SerieDigitada: string;
  ModeloAtual, SerieAtual: Integer;
  i: Integer;
  ChaveAcessoEncontrada: String; // Variável para a chave encontrada no BD
  CodNotaEncontrado: Integer;    // Variável para o PK encontrado no BD
  CodEmitente: Integer;
begin
  // --- 1. COLETAR FILTROS (FIXANDO O MODELO PARA NFC-e - 65) ---

  ModeloAtual := 65; // FIXADO PARA NFC-e

  SerieDigitada := InputBox('Informar Dados', 'Digite a Série da(s) Nota(s) NFC-e (Modelo 65):', '1');
  if SerieDigitada = '' then Exit;

  try
    SerieAtual := StrToInt(SerieDigitada);
  except
    on E: Exception do
    begin
      ShowMessage('❌ Erro: Série deve ser um número válido.');
      Exit;
    end;
  end;

  // Obtém o Código do Emitente selecionado (necessário para a consulta)
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('❌ Erro: Selecione uma empresa emitente para buscar as chaves.');
    Exit;
  end;
  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

  // --- 2. ABRIR DIÁLOGO DE ARQUIVO TXT E PREPARAR CDS ---
  OpenDialog1.Filter := 'Arquivos de Texto (*.txt)|*.txt|Todos os Arquivos (*.*)|*.*';
  OpenDialog1.Title := 'Selecione o arquivo TXT com os NÚMEROS das notas (um por linha)';

  if OpenDialog1.Execute then
  begin
    // Garante que a estrutura do CDS está criada e limpa
    CriarEstruturaCDSConsultaChave;

    ArquivoTXT := TStringList.Create;
    try
      ArquivoTXT.LoadFromFile(OpenDialog1.FileName);

      for LinhaNota in ArquivoTXT do
      begin
        LinhaTrabalhada := Trim(LinhaNota);
        ChaveAcessoEncontrada := ''; // Reseta a chave a cada loop
        CodNotaEncontrado := 0;      // Reseta o CodNota a cada loop

        if TryStrToInt(LinhaTrabalhada, i) then
        begin
          // --- 3. BUSCA DA CHAVE E PK NO BANCO DE DADOS (NFE_CAB) ---
          with DataModule1.QRYNUMNOTASEFAZ do
          try
            Close;
            // IMPORTANTE: Adicionado CodNota ao SELECT
            SQL.Text :=
              'SELECT CodNota, chave_acesso FROM NFE_CAB ' +
              'WHERE Num_Nota_Fiscal = :NumNota ' +
              '  AND CodEmitente = :CodEmitente ' +
              '  AND Num_Mod_Doc = :NumModDoc ' +
              '  AND Num_Serie = :NumSerie;';

            ParamByName('NumNota').AsInteger := StrToInt(LinhaTrabalhada);
            ParamByName('CodEmitente').AsInteger := CodEmitente;
            ParamByName('NumModDoc').AsInteger := ModeloAtual;
            ParamByName('NumSerie').AsInteger := SerieAtual;

            Open;

            if not IsEmpty then
            begin
              CodNotaEncontrado := FieldByName('CodNota').AsInteger;      // <-- CAPTURA DA PK
              ChaveAcessoEncontrada := FieldByName('chave_acesso').AsString;
            end
            else
              MemoConsulta.Lines.Add(Format('⚠️ Aviso: Chave não encontrada no BD para Nota %s.', [LinhaTrabalhada]));

          finally
            Close;
          end;

          // --- 4. INSERE A NOTA, CHAVE E PK NO CDS ---
          DataModule1.CDSCONSULTACHAVE.Append;
          DataModule1.CDSCONSULTACHAVE.FieldByName('NumNota').AsInteger := StrToInt(LinhaTrabalhada);
          DataModule1.CDSCONSULTACHAVE.FieldByName('Modelo').AsInteger := ModeloAtual;
          DataModule1.CDSCONSULTACHAVE.FieldByName('Serie').AsInteger := SerieAtual;
          DataModule1.CDSCONSULTACHAVE.FieldByName('CodNota').AsInteger := CodNotaEncontrado;        // <-- INSERÇÃO DA PK
          DataModule1.CDSCONSULTACHAVE.FieldByName('chave_acesso').AsString := ChaveAcessoEncontrada;
          DataModule1.CDSCONSULTACHAVE.FieldByName('Status').AsString := IfThen(CodNotaEncontrado <> 0, 'ENCONTRADA', 'FALTANTE');
          DataModule1.CDSCONSULTACHAVE.FieldByName('cStat').AsInteger := 0;
          DataModule1.CDSCONSULTACHAVE.Post;
        end
        else if LinhaTrabalhada <> '' then
        begin
          MemoConsulta.Lines.Add(Format('⚠️ Linha ignorada: "%s" (Não é um número).', [LinhaTrabalhada]));
        end;
      end;

      ShowMessage(Format('Importação concluída. %d notas processadas. Chaves buscadas no BD.', [DataModule1.CDSCONSULTACHAVE.RecordCount]));
    finally
      ArquivoTXT.Free;
    end;
  end
  else
  begin
    ShowMessage('Importação de arquivo TXT cancelada pelo usuário.');
  end;
end;




procedure Tfrmmenu.CriarEstruturaCDSConsultaChave;
begin
  // Acessa o TClientDataSet no DataModule1
  with DataModule1.CDSCONSULTACHAVE do
  begin
    if Active then
      Close;

    FieldDefs.Clear;

    // 1. Campo para o NÚMERO DA NOTA (input do usuário)
    FieldDefs.Add('NumNota', ftInteger);

    // 2. Campo para o MODELO (input do usuário, ex: 55, 65)
    FieldDefs.Add('Modelo', ftInteger);

    // 3. Campo para a SÉRIE (input do usuário)
    FieldDefs.Add('Serie', ftInteger);

    // 4. Campo para a CHAVE PRIMÁRIA DA TABELA (CRÍTICO PARA UPDATE)
    FieldDefs.Add('CodNota', ftInteger);

    // 5. Campo para a CHAVE DE ACESSO (buscada no BD e exibida)
    FieldDefs.Add('Chave_acesso', ftString, 44);

    // 6. Campo para o STATUS DE RETORNO DA SEFAZ
    FieldDefs.Add('Status', ftString, 100);

    // 7. Campo para o CÓDIGO DO STATUS (cStat)
    FieldDefs.Add('cStat', ftInteger);

    CreateDataSet;
    Open;
  end;
end;


procedure Tfrmmenu.consultaxmllista;
var
  EsperaForm: TfrmEspera;
  ChaveDaNota: string;
  NumeroDaNota: string;
  CodNotaAtual: Integer;
  cStat: Integer;
  xMotivo: string;
  sXMLComProtocolo: string;
  sXMLOriginal: string;
  sXMLFinal: string;
begin
  // *************************************************************
  // 1. VALIDAÇÃO E INICIALIZAÇÃO
  // *************************************************************

  if not DataModule1.CDSCONSULTACHAVE.Active or DataModule1.CDSCONSULTACHAVE.IsEmpty then
  begin
    ShowMessage('❌ A lista de notas pendentes está vazia. Execute a importação de lista primeiro!');
    Exit;
  end;

  // -- VALIDAÇÃO DO CERTIFICADO E CONFIGURAÇÃO
  if frmACBrNFe.edtNumSerie.Text = '' then
  begin
    ShowMessage('❌ O Número de Série do Certificado não está preenchido na configuração (Configurações > Certificado). Operação cancelada.');
    Exit;
  end;

  frmACBrNFe.ACBrNFe1.Configuracoes.Certificados.NumeroSerie := frmACBrNFe.edtNumSerie.Text;

  // Prepara a interface de feedback
  MEMOCONSULTA.Lines.Clear;
  MEMOCONSULTA.Lines.Add('Iniciando consulta de NFC-e (Modelo 65) na SEFAZ...');
  Application.ProcessMessages;

  EsperaForm := TfrmEspera.Create(Self);
  try
    EsperaForm.Position := poScreenCenter;
    EsperaForm.Label1.Caption := 'Consultando Chaves Pendentes (NFC-e) na SEFAZ...';
    EsperaForm.Show;
    Application.ProcessMessages;

    DataModule1.CDSCONSULTACHAVE.DisableControls;
    DataModule1.CDSCONSULTACHAVE.First;

    while not DataModule1.CDSCONSULTACHAVE.Eof do
    begin
      ChaveDaNota := DataModule1.CDSCONSULTACHAVE.FieldByName('Chave_Acesso').AsString;
      NumeroDaNota := DataModule1.CDSCONSULTACHAVE.FieldByName('NumNota').AsString;
      CodNotaAtual := DataModule1.CDSCONSULTACHAVE.FieldByName('CodNota').AsInteger;

      if Length(ChaveDaNota) = 44 then
      begin
        MEMOCONSULTA.Lines.Add(Format('🔎 Consultando nota %s pela Chave %s', [NumeroDaNota, ChaveDaNota]));
        Application.ProcessMessages;

        try
          frmACBrNFe.ACBrNFe1.WebServices.Consulta.NFeChave := ChaveDaNota;
          frmACBrNFe.ACBrNFe1.WebServices.Consulta.Executar;

          cStat := frmACBrNFe.ACBrNFe1.WebServices.Consulta.cStat;
          xMotivo := frmACBrNFe.ACBrNFe1.WebServices.Consulta.xMotivo;
          sXMLComProtocolo := frmACBrNFe.ACBrNFe1.WebServices.Consulta.RetornoWS;
        except
          on E: Exception do
          begin
            cStat := 999;
            xMotivo := 'Erro de Comunicação ACBr: ' + E.Message;
            sXMLComProtocolo := '';
          end;
        end;

        MEMOCONSULTA.Lines.Add(Format('✅ Resposta SEFAZ | Status: %d | Motivo: %s', [cStat, xMotivo]));

        if (cStat = 100) or (cStat = 150) then
        begin
          sXMLOriginal := BuscarXMLGeracao(CodNotaAtual);
          sXMLFinal := MesclarXMLComProtocolo(sXMLOriginal, sXMLComProtocolo);
          AtualizarStatusEProtocolo(CodNotaAtual, ChaveDaNota, cStat, xMotivo, sXMLFinal);
          MEMOCONSULTA.Lines.Add('⭐⭐ Nota AUTORIZADA! Aplicando Atualização...');
          ExecutarUpdateNotasFiscais;
        end
        else
        begin
          AtualizarStatusEProtocolo(CodNotaAtual, ChaveDaNota, cStat, xMotivo, sXMLComProtocolo);
        end;
      end
      else
        MEMOCONSULTA.Lines.Add(Format('⚠️ Chave XML inválida (%s) para a nota %s. Pulando...', [ChaveDaNota, NumeroDaNota]));

      // 👉 Adiciona espaço entre as consultas para melhor leitura
      MEMOCONSULTA.Lines.Add('');

      DataModule1.CDSCONSULTACHAVE.Next;
    end;

    MEMOCONSULTA.Lines.Add('✅ Consulta de lista pendente concluída. Verifique os logs de Autorização/Rejeição.');

  finally
    DataModule1.CDSCONSULTACHAVE.EnableControls;
    if Assigned(EsperaForm) then
    begin
      EsperaForm.Close;
      EsperaForm.Free;
    end;
  end;
end;






procedure Tfrmmenu.ModificarESalvarXMLGeracao;
var
  XMLGeracao: string;
  NumNota: string;
  CodNotaAtual: Integer;
  DataAtual: TDateTime;
  NovaDataHoraSimples: string;
  sXMLAjustado: string;
  PosInicioData: Integer;
  ConteudoAntigo: string;
  PosInicioSignature, PosFimSignature: Integer;
  PosInicioTpEmis: Integer;
  TpEmisAntigo: string;
  PosInicioXJust, PosFimXJust: Integer;
  PosInicioDhCont, PosFimDhCont: Integer;
  PosFimDetPag: Integer;
  Rejeicao: string;

  // Variáveis para correção de NCM (Rejeição 805) - Agora declaradas corretamente
  PosInicioNCM, PosFimNCM, PosCursor, I: Integer;
  NCM_Antigo: string;
  NumItem: Integer;
  NCM_Específico_Encontrado: Boolean;

  // Variáveis para correção de PIX (Bloco 6) - Agora declaradas corretamente
  PosInicioPix, PosFimDetPagPix, PosCardPix: Integer;
  sDetPagPix: string;

  const
    // Constantes NCM
    NCM_INVALIDOS_ESPECIFICOS: array[0..0] of string = ('38089198'); // Adicione mais NCMs problemáticos aqui
    NCM_CORRETO_GENERICO = '00000000';
    // Constante PIX
    BLOCO_CARD_PIX = '<card><tpIntegra>2</tpIntegra></card>'; // tpIntegra=2: Pagamento no estabelecimento

begin
  logpendentes.Lines.Clear;

  if not DataModule1.QRYPSQPENDENTE.Active or DataModule1.QRYPSQPENDENTE.IsEmpty then
  begin
    logpendentes.Lines.Add('❌ Lista de notas pendentes vazia. Nada para modificar.');
    Exit;
  end;

  logpendentes.Lines.Add('🔄 Modificando e salvando Nota no Banco de Dados...');
  Application.ProcessMessages;

  DataModule1.QRYPSQPENDENTE.DisableControls;
  DataModule1.QRYPSQPENDENTE.First;

  while not DataModule1.QRYPSQPENDENTE.Eof do
  begin
    XMLGeracao    := DataModule1.QRYPSQPENDENTE.FieldByName('XMLGeracao').AsString;
    NumNota       := DataModule1.QRYPSQPENDENTE.FieldByName('NumNota').AsString;
    CodNotaAtual  := DataModule1.QRYPSQPENDENTE.FieldByName('CodNota').AsInteger;
    Rejeicao      := DataModule1.QRYPSQPENDENTE.FieldByName('RejeicaoMotivo').AsString;

    XMLGeracao := Trim(XMLGeracao);
    if XMLGeracao <> '' then
    begin
      sXMLAjustado := XMLGeracao;

      // 1. Remover assinatura (para permitir a re-assinatura)
      PosInicioSignature := Pos('<Signature', sXMLAjustado);
      PosFimSignature := Pos('</Signature>', sXMLAjustado);
      if (PosInicioSignature > 0) and (PosFimSignature > 0) then
      begin
        sXMLAjustado := Copy(sXMLAjustado, 1, PosInicioSignature - 1) +
                        Copy(sXMLAjustado, PosFimSignature + Length('</Signature>'), Length(sXMLAjustado));
        logpendentes.Lines.Add(Format('✂️ Nota %s: Assinatura removida.', [NumNota]));
      end;

      // 2. Ajustar data/hora de emissão para o momento atual
      DataAtual := Now;
      NovaDataHoraSimples := FormatDateTime('yyyy-mm-dd', DataAtual) + 'T' + FormatDateTime('hh:nn:ss', DataAtual);
      PosInicioData := Pos('<dhEmi>', sXMLAjustado);
      if PosInicioData > 0 then
      begin
        PosInicioData := PosInicioData + Length('<dhEmi>');
        ConteudoAntigo := Copy(sXMLAjustado, PosInicioData, 19);
        sXMLAjustado := StringReplace(sXMLAjustado, ConteudoAntigo, NovaDataHoraSimples, [rfReplaceAll]);
        logpendentes.Lines.Add(Format('🔧 Nota %s: Data/Hora ajustada para %s.', [NumNota, NovaDataHoraSimples]));
      end;

      // 3. Ajustar tipo de emissão para 1 (Normal)
      PosInicioTpEmis := Pos('<tpEmis>', sXMLAjustado);
      if PosInicioTpEmis > 0 then
      begin
        PosInicioTpEmis := PosInicioTpEmis + Length('<tpEmis>');
        TpEmisAntigo := Copy(sXMLAjustado, PosInicioTpEmis, 1);
        sXMLAjustado := StringReplace(sXMLAjustado, '<tpEmis>' + TpEmisAntigo, '<tpEmis>1', [rfReplaceAll]);
        if TpEmisAntigo <> '1' then
          logpendentes.Lines.Add(Format('🔧 Nota %s: Tipo Emissão alterado de %s para 1 (Normal).', [NumNota, TpEmisAntigo]));
      end;

      // 4. Remover Justificativa e Data de Contingência (campos de Contingência)
      PosInicioXJust := Pos('<xJust>', sXMLAjustado);
      PosFimXJust := Pos('</xJust>', sXMLAjustado);
      if (PosInicioXJust > 0) and (PosFimXJust > 0) then
      begin
        sXMLAjustado := Copy(sXMLAjustado, 1, PosInicioXJust - 1) +
                        Copy(sXMLAjustado, PosFimXJust + Length('</xJust>'), Length(sXMLAjustado));
        logpendentes.Lines.Add(Format('🧹 Nota %s: Justificativa (xJust) removida.', [NumNota]));
      end;

      PosInicioDhCont := Pos('<dhCont>', sXMLAjustado);
      PosFimDhCont := Pos('</dhCont>', sXMLAjustado);
      if (PosInicioDhCont > 0) and (PosFimDhCont > 0) then
      begin
        sXMLAjustado := Copy(sXMLAjustado, 1, PosInicioDhCont - 1) +
                        Copy(sXMLAjustado, PosFimDhCont + Length('</dhCont>'), Length(sXMLAjustado));
        logpendentes.Lines.Add(Format('🧹 Nota %s: Data de Contingência (dhCont) removida.', [NumNota]));
      end;

      // 5. CORREÇÃO NCM (Rejeição 805): Ajustar NCMs inválidos ou descontinuados para '00000000'
      PosCursor := 1;
      NumItem := 1;
      while (PosCursor > 0) do
      begin
        PosInicioNCM := PosEx('<NCM>', sXMLAjustado, PosCursor);
        PosFimNCM := PosEx('</NCM>', sXMLAjustado, PosCursor);

        if (PosInicioNCM > 0) and (PosFimNCM > 0) then
        begin
          PosInicioNCM := PosInicioNCM + Length('<NCM>');
          NCM_Antigo := Copy(sXMLAjustado, PosInicioNCM, PosFimNCM - PosInicioNCM);
          NCM_Antigo := Trim(NCM_Antigo);

          NCM_Específico_Encontrado := False;
          for I := Low(NCM_INVALIDOS_ESPECIFICOS) to High(NCM_INVALIDOS_ESPECIFICOS) do
          begin
            if NCM_Antigo = NCM_INVALIDOS_ESPECIFICOS[I] then
            begin
              NCM_Específico_Encontrado := True;
              Break;
            end;
          end;

          // Critério de Correção: NCM com menos de 8 dígitos, vazio OU NCM específico na lista
          if (Length(NCM_Antigo) <> 8) or (NCM_Antigo = '') or NCM_Específico_Encontrado then
          begin
            sXMLAjustado := StringReplace(sXMLAjustado,
                                          '<NCM>' + NCM_Antigo + '</NCM>',
                                          '<NCM>' + NCM_CORRETO_GENERICO + '</NCM>',
                                          []); // Sem rfReplaceAll
            logpendentes.Lines.Add(Format('🛠️ Nota %s: NCM do item %d corrigido de "%s" para "%s" (Genérico).',
                                          [NumNota, NumItem, NCM_Antigo, NCM_CORRETO_GENERICO]));
          end;

          PosCursor := PosFimNCM + Length('</NCM>');
          Inc(NumItem);
        end
        else
          PosCursor := 0;
      end;

      // 6. CORREÇÃO PIX MULTI-PAGAMENTO: Adicionar <card> para tPag=17 (PIX) se ausente no bloco
      PosInicioPix := 1;
      while PosInicioPix > 0 do
      begin
        // 6a. Encontra o início do bloco PIX
        PosInicioPix := PosEx('<tPag>17</tPag>', sXMLAjustado, PosInicioPix);

        if PosInicioPix > 0 then
        begin
          // 6b. Encontra o fechamento do bloco </detPag> APÓS o início do PIX
          PosFimDetPagPix := PosEx('</detPag>', sXMLAjustado, PosInicioPix);

          if (PosFimDetPagPix > 0) then
          begin
            // 6c. Isola a substring do bloco de pagamento PIX para verificar a existência do <card>
            sDetPagPix := Copy(sXMLAjustado, PosInicioPix, PosFimDetPagPix + Length('</detPag>') - PosInicioPix);

            // 6d. Verifica se a tag <card> JÁ existe dentro DESTE bloco PIX
            PosCardPix := Pos('<card>', sDetPagPix);

            if PosCardPix = 0 then // Se NÃO encontrou <card> no bloco PIX
            begin
              // Substitui o padrão de fechamento </vPag></detPag> pelo padrão corrigido
              // Nota: Usa-se o StringReplace em todo o sXMLAjustado para cobrir o caso,
              // mas a checagem no sub-bloco é que garante a correção necessária.
              sXMLAjustado := StringReplace(sXMLAjustado,
                                            '</vPag></detPag>',
                                            '</vPag>' + BLOCO_CARD_PIX + '</detPag>',
                                            [rfReplaceAll]);

              logpendentes.Lines.Add(Format('🛠️ Nota %s: Bloco <card> adicionado para pagamento PIX (tPag=17).', [NumNota]));
            end;
            // Move o cursor de busca para APÓS o bloco PIX atual para buscar o próximo
            PosInicioPix := PosFimDetPagPix + Length('</detPag>');
          end
          else
             PosInicioPix := 0; // Se não encontrou </detPag> após o PIX, sai do loop
        end;
      end;

      // 7. Salvar XML ajustado no SQL Server (Utilizando transação)
      try
        DataModule1.ConDados.StartTransaction;
        with DataModule1.QRYupdatebanco do
        begin
          Close;
          SQL.Clear;
          SQL.Text := 'UPDATE NFE_XML SET XMLGeracao = :pXMLGeracao WHERE CodNota = :pCodNota';
          ParamByName('pXMLGeracao').AsString := sXMLAjustado;
          ParamByName('pCodNota').AsInteger := CodNotaAtual;
          ExecSQL;
        end;
        DataModule1.ConDados.Commit;
        logpendentes.Lines.Add(Format('💾 Nota %s: Atualizada, XML corrigido.', [NumNota]));
      except
        on E: Exception do
        begin
          DataModule1.ConDados.Rollback;
          logpendentes.Lines.Add(Format('❌ Erro CRÍTICO ao atualizar XMLGeracao no BD (CodNota %d): %s',
            [CodNotaAtual, E.Message]));
        end;
      end;

    end
    else
      logpendentes.Lines.Add(Format('⚠️ XMLGeracao vazio para nota %s. Pulando...', [NumNota]));

    DataModule1.QRYPSQPENDENTE.Next;
    Application.ProcessMessages;
  end;

  DataModule1.QRYPSQPENDENTE.EnableControls;
  ConsultarVendasPendentes;
  logpendentes.Lines.Add('✅ Modificação de XMLs concluída. Notas prontas para o reenvio.');
end;









procedure Tfrmmenu.CorrigirPendenciasBaseadoEmServxml;
var
  TotalPendencias, TotalCorrigido: Integer;
begin
  logpendentes.Lines.Add('>>> INICIANDO CORREÇÃO NFE_XML BASEADO EM SERVXML (INUTILIZAÇÕES) <<<');
  Application.ProcessMessages;

  TotalPendencias := 0;
  TotalCorrigido := 0;

  // Etapa 1: Contar pendências antes de iniciar
  with DataModule1.QRYCORRIGEPENDENCIA do
  begin
    Close;
    SQL.Clear;
    SQL.Text :=
      'SELECT COUNT(*) AS Total ' +
      'FROM NFE_XML ' +
      'JOIN SERVXML ON ' +
      '  NFE_XML.NumNota = SERVXML.NumNota AND ' +
      '  NFE_XML.CodEmitente = SERVXML.CodEmitente AND ' +
      '  NFE_XML.Serie COLLATE Latin1_General_CI_AS = SERVXML.Serie ' +
      'WHERE NFE_XML.CodNota > 0 AND SERVXML.Status = ''I''';
    Open;
    TotalPendencias := FieldByName('Total').AsInteger;
  end;

  logpendentes.Lines.Add(Format('🔍 Pendências encontradas: %d', [TotalPendencias]));

  // Etapa 2: Buscar registros para correção
  with DataModule1.QRYCORRIGEPENDENCIA do
  begin
    Close;
    SQL.Clear;
    SQL.Text :=
      'SELECT NFE_XML.CodNota, NFE_XML.NumNota, NFE_XML.Serie, NFE_XML.CodEmitente ' +
      'FROM NFE_XML ' +
      'JOIN SERVXML ON ' +
      '  NFE_XML.NumNota = SERVXML.NumNota AND ' +
      '  NFE_XML.CodEmitente = SERVXML.CodEmitente AND ' +
      '  NFE_XML.Serie COLLATE Latin1_General_CI_AS = SERVXML.Serie ' +
      'WHERE NFE_XML.CodNota > 0 AND SERVXML.Status = ''I''';
    Open;

    if IsEmpty then
    begin
      logpendentes.Lines.Add('✅ Nenhuma inconsistência encontrada. NFE_XML está limpa.');
      Exit;
    end;

    DisableControls;
    First;

    // Etapa 3: Corrigir registros
    while not Eof do
    begin
      logpendentes.Lines.Add(Format('Corrigindo Nota %d...', [FieldByName('NumNota').AsInteger]));
      Application.ProcessMessages;

      mudanotaparanegativo(
        FieldByName('CodNota').AsInteger,
        FieldByName('NumNota').AsInteger
      );

      Inc(TotalCorrigido);
      Next;
    end;

    EnableControls;
  end;

  // Etapa 4: Exibir resumo
  logpendentes.Lines.Add(Format('✅ Corrigidas nesta execução: %d', [TotalCorrigido]));
  logpendentes.Lines.Add(Format('⏳ Pendências restantes: %d', [TotalPendencias - TotalCorrigido]));
  logpendentes.Lines.Add('✅ CORREÇÃO FINALIZADA.');

  // Recarrega a grade de vendas pendentes

end;




procedure Tfrmmenu.ForcarMigracaoXMLTemp;
var
  CodEmitente: Integer;
  TotalRegistrosMigrados: Integer;
begin
  // 1. VALIDAÇÃO E OBTENÇÃO DO EMITENTE
  if cmbempresa.ItemIndex = -1 then
  begin
    ShowMessage('❌ Selecione a empresa emitente.');
    Exit;
  end;
  CodEmitente := Integer(cmbempresa.Items.Objects[cmbempresa.ItemIndex]);

  logpendentes.Lines.Add('>>> INICIANDO MIGRAÇÃO FORÇADA DE NFE_XMLTEMP PARA NFE_XML (APENAS INSERT) <<<');
  logpendentes.Lines.Add('>>> FILTRO: APENAS NOTAS EM CONTINGÊNCIA (tpEmis=9) <<<');
  Application.ProcessMessages;

  try
    // 2. PREPARAÇÃO E EXECUÇÃO DA TRANSAÇÃO
    DataModule1.ConDados.StartTransaction;

    // 2.1. Montagem do SQL testado e funcional
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Clear;

    // INSERT INTO NFE_XML
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('INSERT INTO NFE_XML (CodNota, XMLChave, NumNota, Serie, DataGeracao, XMLGeracao, Status, CodEmitente, Pedido, Valor, Num_Serie) ');

    // SELECT com JOIN NFE_CAB
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('SELECT NC.CodNota, XT.ChaveNFe, XT.Num_Nota_Fiscal, XT.Num_Serie AS Serie, XT.DataCriacao AS DataGeracao, XT.XMLTexto AS XMLGeracao, ''G'' AS Status, XT.CodEmitente, XT.CodVenda AS Pedido, XT.Valor, XT.Num_Serie ');
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('FROM NFE_XMLTemp XT INNER JOIN NFE_CAB NC ON NC.Num_Nota_Fiscal = XT.Num_Nota_Fiscal AND NC.CodEmitente = XT.CodEmitente ');

    // CONDIÇÃO 1: Evita PK duplicada (CodNota)
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('WHERE NOT EXISTS (SELECT 1 FROM NFE_XML X WHERE X.CodNota = NC.CodNota) ');

    // CONDIÇÃO 2: Evita duplicidade por Status Finalizado
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('  AND NOT EXISTS (SELECT 1 FROM NFE_XML X2 WHERE X2.NumNota = XT.Num_Nota_Fiscal AND X2.CodEmitente = XT.CodEmitente AND X2.Status IN (''T'', ''C'', ''I''))');

    // CONDIÇÃO 3: Filtro de Emitente e Status
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('  AND XT.Status = ''G'' ');
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('  AND XT.CodEmitente = :CodEmitente');

    // 🆕 NOVO FILTRO: Apenas XMLs com Tipo de Emissão 9 (Contingência)
    DataModule1.QRYMIGRAR_XMLTEMP.SQL.Add('  AND XT.XMLTexto LIKE ''%<tpEmis>9</tpEmis>%''');

    // 2.2. Execução da Migração
    with DataModule1.QRYMIGRAR_XMLTEMP do
    begin
        Close;
        ParamByName('CodEmitente').AsInteger := CodEmitente;
        ExecSQL;
        TotalRegistrosMigrados := RowsAffected;
    end;
    DataModule1.ConDados.Commit;

    // 3. FEEDBACK E ATUALIZAÇÃO DA INTERFACE
    logpendentes.Lines.Add(Format('✅ MIGRAÇÃO CONCLUÍDA! %d notas migradas para NFE_XML (Status ''G'' e tpEmis=9).', [TotalRegistrosMigrados]));

  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add('❌ ERRO CRÍTICO na Migração (Rollback): ' + E.Message);
      ShowMessage('❌ Erro na migração: ' + E.Message + ' (A transação foi desfeita)');
    end;
  end;
end;





 procedure Tfrmmenu.CriarEstruturaCDSCorretas;
begin
  with datamodule1.CDSCHAVESCORRETAS do
  begin
    if Active then
      Close;

    FieldDefs.Clear;
    FieldDefs.Add('CodNota', ftInteger);      // PK no BD (Para futura referência)
    FieldDefs.Add('NumNota', ftString, 10);    // Número da Nota
    FieldDefs.Add('AntigaChave', ftString, 44); // Chave incorreta no BD
    FieldDefs.Add('NovaChave', ftString, 44);   // Chave correta retornada pela SEFAZ
    FieldDefs.Add('CodEmitente', ftInteger);
    FieldDefs.Add('Serie', ftString, 3);

    CreateDataSet;
    Open;
  end;
end;









function Tfrmmenu.ExtrairChaveCorreta(const AXMotivo: string): string;
// Localiza a chave correta dentro do motivo da rejeição 613.
const
  TokenInicio = '['; // Início da chave
  TokenFim = ']';   // Fim da chave
var
  PosInicio, PosFim: Integer;
begin
  Result := '';

  // 1. Garante que o motivo contenha a parte do erro com a chave.
  if Pos('Chave de Acesso difere', AXMotivo) > 0 then
  begin
    // 2. Localiza o início dos colchetes
    PosInicio := Pos(TokenInicio, AXMotivo);

    if PosInicio > 0 then
    begin
      // 3. O início do conteúdo é logo após o colchete de abertura
      PosInicio := PosInicio + Length(TokenInicio);

      // 4. Localiza o colchete de fechamento a partir do início do conteúdo
      PosFim := PosEx(TokenFim, AXMotivo, PosInicio);

      if PosFim > PosInicio then
      begin
        // 5. Extrai a chave de acesso (44 dígitos)
        Result := Copy(AXMotivo, PosInicio, 44);
        // O copy(..., 44) garante que apenas a chave de 44 dígitos seja copiada,
        // mesmo que o final da string seja mais longo ou desformatado.
      end;
    end;
  end;

  // 6. Validação final: se a string tem 44 dígitos, ela é provavelmente a chave.
  if Length(Result) <> 44 then
    Result := '';
end;


procedure Tfrmmenu.SalvarChaveCorreta(const ACodNota: Integer; const ANovaChave: string);
// Realiza o UPDATE na tabela NFE_XML para salvar a chave correta.
begin
  if (ACodNota = 0) or (Length(ANovaChave) <> 44) then
  begin
    logpendentes.Lines.Add('❌ Erro: Não é possível salvar chave correta com parâmetros inválidos.');
    Exit;
  end;

  try
    DataModule1.ConDados.StartTransaction;

    with DataModule1.QRYCHAVEDIFERENTE do
    begin
      Close;
      SQL.Clear;
      // Atualiza a coluna 'chavecorreta' na NFE_XML
      SQL.Add('UPDATE NFE_XML SET chavecorreta = :pNovaChave ');
      // Atualiza o Status para 'G' (Gerada/Pendente) se não for Rejeição 613,
      // para garantir que a rotina de reenvio tente novamente com a chave correta
      SQL.Add('WHERE CodNota = :pCodNota AND ST_Retorno = 613');
      // Se quiser que o reenvio tente com a chave correta, a condição deve ser mantida

      ParamByName('pNovaChave').AsString := ANovaChave;
      ParamByName('pCodNota').AsInteger := ACodNota;

      ExecSQL;
    end;

    DataModule1.ConDados.Commit;
    logpendentes.Lines.Add(Format('🔑 Chave Correta Salva! CodNota %d. Nova Chave: %s',
      [ACodNota, ANovaChave]));
  except
    on E: Exception do
    begin
      DataModule1.ConDados.Rollback;
      logpendentes.Lines.Add(Format('❌ Erro ao salvar chavecorreta (CodNota %d): %s',
        [ACodNota, E.Message]));
    end;
  end;
end;


procedure Tfrmmenu.AtualizarChavesCorretas;
var
  TotalCorrigido: Integer;
  ChaveAntiga, ChaveNova: string;
  CodNotaAtual: Integer;
begin
  logpendentes.Lines.Add('>>> INICIANDO CORREÇÃO DE CHAVES DE ACESSO NO BANCO DE DADOS <<<');
  Application.ProcessMessages;

  // 1. Consulta as notas que precisam de correção (onde chavecorreta está preenchida)
  with DataModule1.QRYPSQPENDENTE do
  try
    Close;
    // Seleciona notas rejeitadas por 613 que já têm a chave correta salva.
    SQL.Text := 'SELECT CodNota, XMLChave, chavecorreta, NumNota, Serie ' +
                'FROM NFE_XML ' +
                'WHERE ST_Retorno = 613 AND Status = ''G'' AND chavecorreta IS NOT NULL AND XMLChave <> chavecorreta';
    Open;

    TotalCorrigido := 0;

    if IsEmpty then
    begin
      logpendentes.Lines.Add('✅ Nenhuma nota encontrada para correção de chave (Erro 613).');
      Exit;
    end;

    DisableControls;
    First;

    // 2. Itera e aplica a correção por registro (transação por nota para isolamento)
    while not Eof do
    begin
      CodNotaAtual := FieldByName('CodNota').AsInteger;
      ChaveAntiga := FieldByName('XMLChave').AsString;
      ChaveNova := FieldByName('chavecorreta').AsString;

      logpendentes.Lines.Add(Format('🔄 Corrigindo Nota %d. Chave Antiga: %s -> Nova: %s', [CodNotaAtual, Copy(ChaveAntiga, 35, 10), Copy(ChaveNova, 35, 10)]));
      Application.ProcessMessages;

      // --- INÍCIO DA TRANSAÇÃO POR NOTA ---
      try
        DataModule1.ConDados.StartTransaction;

        // 2.1. CORREÇÃO NA NFE_XML (Chave principal e texto do XML)
        with DataModule1.QRYATUALIZACHAVE do
        begin
          Close;
          SQL.Clear;
          // Atualiza a XMLChave, corrige o status e limpa a coluna temporária
          SQL.Add('UPDATE NFE_XML SET ');
          SQL.Add('  XMLChave = :pNovaChave, ');
          SQL.Add('  Status = ''G'', '); // Mantém 'G' para reenvio
          SQL.Add('  ST_Retorno = NULL, ');
          SQL.Add('  RejeicaoMotivo = ''AGUARDANDO REENVIO - CHAVE ATUALIZADA'', ');
          SQL.Add('  chavecorreta = NULL, '); // Limpa a chave temporária
          // Corrige o texto XML em XMLGeracao (substitui a chave antiga pela nova)
          SQL.Add('  XMLGeracao = REPLACE(CAST(XMLGeracao AS VARCHAR(MAX)), :pChaveAntiga, :pNovaChave), ');
          // Corrige o texto XML em XMLTransmissao (se houver, substitui a chave antiga pela nova)
          SQL.Add('  XMLTransmissao = REPLACE(CAST(XMLTransmissao AS VARCHAR(MAX)), :pChaveAntiga, :pNovaChave) ');
          SQL.Add('WHERE CodNota = :pCodNota');

          ParamByName('pNovaChave').AsString := ChaveNova;
          ParamByName('pChaveAntiga').AsString := ChaveAntiga;
          ParamByName('pCodNota').AsInteger := CodNotaAtual;
          ExecSQL;
        end;

        // 2.2. CORREÇÃO NA NFE_CAB (Atualiza o campo Chave_Acesso)
        with DataModule1.QRYATUALIZACHAVE do
        begin
          Close;
          SQL.Clear;
          // Usa o CodNota para atualizar a NFE_CAB
          SQL.Add('UPDATE NFE_CAB SET Chave_Acesso = :pNovaChave ');
          SQL.Add('WHERE CodNota = :pCodNota');
          // (NumNota=Num_Nota_Fiscal já é garantido pela integridade, o CodNota é a PK/ligação)

          ParamByName('pNovaChave').AsString := ChaveNova;
          ParamByName('pCodNota').AsInteger := CodNotaAtual;
          ExecSQL;
        end;

        DataModule1.ConDados.Commit;
        logpendentes.Lines.Add(Format('✅ Nota %d: Chaves (XML, CAB) e Conteúdo XML corrigidos com sucesso.', [CodNotaAtual]));
        Inc(TotalCorrigido);

      except // Captura erro da transação SQL
        on E: Exception do
        begin
          DataModule1.ConDados.Rollback;
          logpendentes.Lines.Add(Format('❌ Erro na transação da Nota %d: %s (Rollback executado)', [CodNotaAtual, E.Message]));
        end;
      end;
      // --- FIM DA TRANSAÇÃO POR NOTA ---

      Next;
    end;
  finally
    EnableControls;
  end;

  // 3. Finalização
  logpendentes.Lines.Add('---');
  logpendentes.Lines.Add(Format('✅ PROCESSO CONCLUÍDO. Total de notas corrigidas: %d.', [TotalCorrigido]));
 // ConsultarVendasPendentes; // Recarrega a lista
end;











































































































end.
